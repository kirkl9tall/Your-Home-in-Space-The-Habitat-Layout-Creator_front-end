(function(){"use strict";var Ye,Wi;function K1(){return Wi||(Wi=1,Ye=(e,t,n)=>(e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e)),Ye}var Xe,Qi;function He(){return Qi||(Qi=1,Xe=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),Xe}var Ue,Ki;function j1(){if(Ki)return Ue;Ki=1;const o=He();return Ue=t=>{const n=o();return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},Ue}var We,ji;function Ji(){return ji||(ji=1,We=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e)),We}var Qe,ec;function J1(){return ec||(ec=1,Qe=(e,t)=>{const n=t[0],r=t[1],s=t[2],i=t[3],c=t[4],a=t[5],l=t[6],d=t[7],u=t[8],h=t[9],f=t[10],v=t[11],m=t[12],g=t[13],p=t[14],y=t[15],q=n*a-r*c,P=n*l-s*c,x=n*d-i*c,w=r*l-s*a,E=r*d-i*a,R=s*d-i*l,b=u*g-h*m,M=u*p-f*m,_=u*y-v*m,S=h*p-f*g,A=h*y-v*g,T=f*y-v*p;let $=q*T-P*A+x*S+w*_-E*M+R*b;return $?($=1/$,e[0]=(a*T-l*A+d*S)*$,e[1]=(s*A-r*T-i*S)*$,e[2]=(g*R-p*E+y*w)*$,e[3]=(f*E-h*R-v*w)*$,e[4]=(l*_-c*T-d*M)*$,e[5]=(n*T-s*_+i*M)*$,e[6]=(p*x-m*R-y*P)*$,e[7]=(u*R-f*x+v*P)*$,e[8]=(c*A-a*_+d*b)*$,e[9]=(r*_-n*A-i*b)*$,e[10]=(m*E-g*x+y*q)*$,e[11]=(h*x-u*E-v*q)*$,e[12]=(a*M-c*S-l*b)*$,e[13]=(n*S-r*M+s*b)*$,e[14]=(g*P-m*w-p*q)*$,e[15]=(u*w-h*P+f*q)*$,e):null}),Qe}var Ke,tc;function ed(){return tc||(tc=1,Ke=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]),Ke}var je,nc;function z(){if(nc)return je;nc=1;const o=1e5,e=1e-5,t=1e-13,n=Math.PI*2;return je={EPS:e,NEPS:t,TAU:n,spatialResolution:o},je}var Je,rc;function j(){if(rc)return Je;rc=1;const{NEPS:o}=z(),e=r=>Math.abs(r)<o?0:r;return Je={sin:r=>e(Math.sin(r)),cos:r=>e(Math.cos(r))},Je}var et,sc;function oc(){return sc||(sc=1,et=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)),et}var tt,ic;function cc(){if(ic)return tt;ic=1;const{EPS:o}=z(),{sin:e,cos:t}=j(),n=oc();return tt=(s,i,c)=>{let[a,l,d]=c;const u=a*a+l*l+d*d;if(Math.abs(u)<o)return n(s);const h=1/Math.sqrt(u);a*=h,l*=h,d*=h;const f=e(i),v=t(i),m=1-v;return s[0]=a*a*m+v,s[1]=l*a*m+d*f,s[2]=d*a*m-l*f,s[3]=0,s[4]=a*l*m-d*f,s[5]=l*l*m+v,s[6]=d*l*m+a*f,s[7]=0,s[8]=a*d*m+l*f,s[9]=l*d*m-a*f,s[10]=d*d*m+v,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s},tt}var nt,ac;function td(){return ac||(ac=1,nt=(e,t)=>(e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)),nt}var rt,lc;function nd(){if(lc)return rt;lc=1;const{sin:o,cos:e}=j();return rt=(n,r,s,i)=>{const c=o(r),a=e(r),l=o(s),d=e(s),u=o(i),h=e(i);return n[0]=d*a,n[1]=d*c,n[2]=-l,n[3]=0,n[4]=u*l*a-h*c,n[5]=h*a+u*l*c,n[6]=u*d,n[7]=0,n[8]=u*c+h*l*a,n[9]=h*l*c-u*a,n[10]=h*d,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},rt}var st,uc;function rd(){return uc||(uc=1,st=(e,t)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e)),st}var ot,fc;function sd(){if(fc)return ot;fc=1;const o=He();return ot=(t,n,r,s,i,c,a,l,d,u,h,f,v,m,g,p)=>{const y=o();return y[0]=t,y[1]=n,y[2]=r,y[3]=s,y[4]=i,y[5]=c,y[6]=a,y[7]=l,y[8]=d,y[9]=u,y[10]=h,y[11]=f,y[12]=v,y[13]=m,y[14]=g,y[15]=p,y},ot}var it,hc;function dc(){return hc||(hc=1,it=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e)),it}var ct,pc;function gc(){return pc||(pc=1,ct=(e,t,n)=>(e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e)),ct}var at,vc;function Re(){return vc||(vc=1,at=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]),at}var lt,mc;function od(){if(mc)return lt;mc=1;const o=Re();return lt=(t,n)=>{const r=t[0],s=t[1],i=t[2],c=n[0],a=n[1],l=n[2],d=Math.sqrt(r*r+s*s+i*i),u=Math.sqrt(c*c+a*a+l*l),h=d*u,f=h&&o(t,n)/h;return Math.acos(Math.min(Math.max(f,-1),1))},lt}var ut,yc;function Se(){return yc||(yc=1,ut=()=>[0,0,0]),ut}var ft,xc;function id(){if(xc)return ft;xc=1;const o=Se();return ft=t=>{const n=o();return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},ft}var ht,qc;function wc(){return qc||(qc=1,ht=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e)),ht}var dt,Pc;function me(){return Pc||(Pc=1,dt=(e,t,n)=>{const r=t[0],s=t[1],i=t[2],c=n[0],a=n[1],l=n[2];return e[0]=s*l-i*a,e[1]=i*c-r*l,e[2]=r*a-s*c,e}),dt}var pt,Ec;function Rc(){return Ec||(Ec=1,pt=(e,t)=>{const n=t[0]-e[0],r=t[1]-e[1],s=t[2]-e[2];return Math.sqrt(n*n+r*r+s*s)}),pt}var gt,Sc;function cd(){return Sc||(Sc=1,gt=(e,t,n)=>(e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e)),gt}var vt,$c;function ad(){return $c||($c=1,vt=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]),vt}var mt,_c;function ld(){return _c||(_c=1,mt=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e)),mt}var yt,bc;function ud(){if(bc)return yt;bc=1;const o=Se();return yt=(t,n,r)=>{const s=o();return s[0]=t,s[1]=n,s[2]=r,s},yt}var xt,Ac;function fd(){return Ac||(Ac=1,xt=(e,t,n=0)=>(e[0]=t[0],e[1]=t[1],e[2]=n,e)),xt}var qt,Mc;function Tc(){return Mc||(Mc=1,qt=e=>{const t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}),qt}var wt,Fc;function hd(){return Fc||(Fc=1,wt=(e,t,n,r)=>(e[0]=t[0]+r*(n[0]-t[0]),e[1]=t[1]+r*(n[1]-t[1]),e[2]=t[2]+r*(n[2]-t[2]),e)),wt}var Pt,Cc;function dd(){return Cc||(Cc=1,Pt=(e,t,n)=>(e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e)),Pt}var Et,Nc;function pd(){return Nc||(Nc=1,Et=(e,t,n)=>(e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e)),Et}var Rt,Ic;function gd(){return Ic||(Ic=1,Rt=(e,t,n)=>(e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e)),Rt}var St,Bc;function vd(){return Bc||(Bc=1,St=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e)),St}var $t,kc;function _t(){return kc||(kc=1,$t=(e,t)=>{const n=t[0],r=t[1],s=t[2];let i=n*n+r*r+s*s;return i>0&&(i=1/Math.sqrt(i)),e[0]=n*i,e[1]=r*i,e[2]=s*i,e}),$t}var bt,Oc;function md(){if(Oc)return bt;Oc=1;const o=dc(),e=Se(),t=me();return bt=(r,s)=>{const i=o(e(),s),c=0+(i[0]<i[1]&&i[0]<i[2]),a=0+(i[1]<=i[0]&&i[1]<i[2]),l=0+(i[2]<=i[0]&&i[2]<=i[1]);return t(r,s,[c,a,l])},bt}var At,Vc;function yd(){return Vc||(Vc=1,At=(e,t,n,r)=>{const s=[],i=[];return s[0]=t[0]-n[0],s[1]=t[1]-n[1],s[2]=t[2]-n[2],i[0]=s[0],i[1]=s[1]*Math.cos(r)-s[2]*Math.sin(r),i[2]=s[1]*Math.sin(r)+s[2]*Math.cos(r),e[0]=i[0]+n[0],e[1]=i[1]+n[1],e[2]=i[2]+n[2],e}),At}var Mt,Lc;function xd(){return Lc||(Lc=1,Mt=(e,t,n,r)=>{const s=[],i=[];return s[0]=t[0]-n[0],s[1]=t[1]-n[1],s[2]=t[2]-n[2],i[0]=s[2]*Math.sin(r)+s[0]*Math.cos(r),i[1]=s[1],i[2]=s[2]*Math.cos(r)-s[0]*Math.sin(r),e[0]=i[0]+n[0],e[1]=i[1]+n[1],e[2]=i[2]+n[2],e}),Mt}var Tt,Dc;function qd(){return Dc||(Dc=1,Tt=(e,t,n,r)=>{const s=[],i=[];return s[0]=t[0]-n[0],s[1]=t[1]-n[1],i[0]=s[0]*Math.cos(r)-s[1]*Math.sin(r),i[1]=s[0]*Math.sin(r)+s[1]*Math.cos(r),e[0]=i[0]+n[0],e[1]=i[1]+n[1],e[2]=t[2],e}),Tt}var Ft,zc;function Gc(){return zc||(zc=1,Ft=(e,t,n)=>(e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e)),Ft}var Ct,Zc;function wd(){return Zc||(Zc=1,Ct=(e,t,n)=>(e[0]=Math.round(t[0]/n)*n+0,e[1]=Math.round(t[1]/n)*n+0,e[2]=Math.round(t[2]/n)*n+0,e)),Ct}var Nt,Yc;function Xc(){return Yc||(Yc=1,Nt=(e,t)=>{const n=t[0]-e[0],r=t[1]-e[1],s=t[2]-e[2];return n*n+r*r+s*s}),Nt}var It,Hc;function Uc(){return Hc||(Hc=1,It=e=>{const t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}),It}var Bt,Wc;function $e(){return Wc||(Wc=1,Bt=(e,t,n)=>(e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e)),Bt}var kt,Qc;function Pd(){return Qc||(Qc=1,kt=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`),kt}var Ot,Kc;function Ed(){return Kc||(Kc=1,Ot=(e,t,n)=>{const r=t[0],s=t[1],i=t[2];let c=n[3]*r+n[7]*s+n[11]*i+n[15];return c=c||1,e[0]=(n[0]*r+n[4]*s+n[8]*i+n[12])/c,e[1]=(n[1]*r+n[5]*s+n[9]*i+n[13])/c,e[2]=(n[2]*r+n[6]*s+n[10]*i+n[14])/c,e}),Ot}var Vt,jc;function B(){return jc||(jc=1,Vt={abs:dc(),add:gc(),angle:od(),clone:id(),copy:wc(),create:Se(),cross:me(),distance:Rc(),divide:cd(),dot:Re(),equals:ad(),fromScalar:ld(),fromValues:ud(),fromVec2:fd(),length:Tc(),lerp:hd(),max:dd(),min:pd(),multiply:gd(),negate:vd(),normalize:_t(),orthogonal:md(),rotateX:yd(),rotateY:xd(),rotateZ:qd(),scale:Gc(),snap:wd(),squaredDistance:Xc(),squaredLength:Uc(),subtract:$e(),toString:Pd(),transform:Ed()}),Vt}var Lt,Jc;function Rd(){if(Jc)return Lt;Jc=1;const o=B(),e=cc();return Lt=(n,r,s)=>{const i=o.normalize(o.create(),r),c=o.normalize(o.create(),s),a=o.cross(o.create(),c,i),l=o.dot(c,i);if(l===-1)return e(n,Math.PI,o.orthogonal(a,i));const d=1/(1+l);return n[0]=a[0]*a[0]*d+l,n[1]=a[1]*a[0]*d-a[2],n[2]=a[2]*a[0]*d+a[1],n[3]=0,n[4]=a[0]*a[1]*d+a[2],n[5]=a[1]*a[1]*d+l,n[6]=a[2]*a[1]*d-a[0],n[7]=0,n[8]=a[0]*a[2]*d-a[1],n[9]=a[1]*a[2]*d+a[0],n[10]=a[2]*a[2]*d+l,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},Lt}var Dt,ea;function Sd(){if(ea)return Dt;ea=1;const{sin:o,cos:e}=j();return Dt=(n,r)=>{const s=o(r),i=e(r);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=i,n[6]=s,n[7]=0,n[8]=0,n[9]=-s,n[10]=i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},Dt}var zt,ta;function $d(){if(ta)return zt;ta=1;const{sin:o,cos:e}=j();return zt=(n,r)=>{const s=o(r),i=e(r);return n[0]=i,n[1]=0,n[2]=-s,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=s,n[9]=0,n[10]=i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},zt}var Gt,na;function _d(){if(na)return Gt;na=1;const{sin:o,cos:e}=j();return Gt=(n,r)=>{const s=o(r),i=e(r);return n[0]=i,n[1]=s,n[2]=0,n[3]=0,n[4]=-s,n[5]=i,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},Gt}var Zt,ra;function bd(){return ra||(ra=1,Zt=e=>e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1),Zt}var Yt,sa;function Ad(){if(sa)return Yt;sa=1;const o=t=>e(t[1])&&e(t[2])&&e(t[3])&&e(t[4])&&e(t[6])&&e(t[7])&&e(t[8])&&e(t[9])&&e(t[11])&&t[15]===1,e=t=>Math.abs(t)<Number.EPSILON;return Yt=o,Yt}var Xt,oa;function Md(){return oa||(oa=1,Xt=e=>{const t=e[4]*e[9]-e[8]*e[5],n=e[8]*e[1]-e[0]*e[9],r=e[0]*e[5]-e[4]*e[1];return t*e[2]+n*e[6]+r*e[10]<0}),Xt}var Ht,ia;function Td(){return ia||(ia=1,Ht=(e,t)=>{const[n,r,s,i]=t;return e[0]=1-2*n*n,e[1]=-2*r*n,e[2]=-2*s*n,e[3]=0,e[4]=-2*n*r,e[5]=1-2*r*r,e[6]=-2*s*r,e[7]=0,e[8]=-2*n*s,e[9]=-2*r*s,e[10]=1-2*s*s,e[11]=0,e[12]=2*n*i,e[13]=2*r*i,e[14]=2*s*i,e[15]=1,e}),Ht}var Ut,ca;function Fd(){return ca||(ca=1,Ut=(e,t,n)=>{const r=t[0],s=t[1],i=t[2],c=t[3],a=t[4],l=t[5],d=t[6],u=t[7],h=t[8],f=t[9],v=t[10],m=t[11],g=t[12],p=t[13],y=t[14],q=t[15];let P=n[0],x=n[1],w=n[2],E=n[3];return e[0]=P*r+x*a+w*h+E*g,e[1]=P*s+x*l+w*f+E*p,e[2]=P*i+x*d+w*v+E*y,e[3]=P*c+x*u+w*m+E*q,P=n[4],x=n[5],w=n[6],E=n[7],e[4]=P*r+x*a+w*h+E*g,e[5]=P*s+x*l+w*f+E*p,e[6]=P*i+x*d+w*v+E*y,e[7]=P*c+x*u+w*m+E*q,P=n[8],x=n[9],w=n[10],E=n[11],e[8]=P*r+x*a+w*h+E*g,e[9]=P*s+x*l+w*f+E*p,e[10]=P*i+x*d+w*v+E*y,e[11]=P*c+x*u+w*m+E*q,P=n[12],x=n[13],w=n[14],E=n[15],e[12]=P*r+x*a+w*h+E*g,e[13]=P*s+x*l+w*f+E*p,e[14]=P*i+x*d+w*v+E*y,e[15]=P*c+x*u+w*m+E*q,e}),Ut}var Wt,aa;function Cd(){if(aa)return Wt;aa=1;const{EPS:o}=z(),{sin:e,cos:t}=j(),n=Ji();return Wt=(s,i,c,a)=>{let[l,d,u]=a;const h=l*l+d*d+u*u;if(Math.abs(h)<o)return n(s,i);const f=1/Math.sqrt(h);l*=f,d*=f,u*=f;const v=e(c),m=t(c),g=1-m,p=i[0],y=i[1],q=i[2],P=i[3],x=i[4],w=i[5],E=i[6],R=i[7],b=i[8],M=i[9],_=i[10],S=i[11],A=l*l*g+m,T=d*l*g+u*v,$=u*l*g-d*v,F=l*d*g-u*v,C=d*d*g+m,N=u*d*g+l*v,I=l*u*g+d*v,k=d*u*g-l*v,V=u*u*g+m;return s[0]=p*A+x*T+b*$,s[1]=y*A+w*T+M*$,s[2]=q*A+E*T+_*$,s[3]=P*A+R*T+S*$,s[4]=p*F+x*C+b*N,s[5]=y*F+w*C+M*N,s[6]=q*F+E*C+_*N,s[7]=P*F+R*C+S*N,s[8]=p*I+x*k+b*V,s[9]=y*I+w*k+M*V,s[10]=q*I+E*k+_*V,s[11]=P*I+R*k+S*V,i!==s&&(s[12]=i[12],s[13]=i[13],s[14]=i[14],s[15]=i[15]),s},Wt}var Qt,la;function Nd(){if(la)return Qt;la=1;const{sin:o,cos:e}=j();return Qt=(n,r,s)=>{const i=o(s),c=e(s),a=r[4],l=r[5],d=r[6],u=r[7],h=r[8],f=r[9],v=r[10],m=r[11];return r!==n&&(n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15]),n[4]=a*c+h*i,n[5]=l*c+f*i,n[6]=d*c+v*i,n[7]=u*c+m*i,n[8]=h*c-a*i,n[9]=f*c-l*i,n[10]=v*c-d*i,n[11]=m*c-u*i,n},Qt}var Kt,ua;function Id(){if(ua)return Kt;ua=1;const{sin:o,cos:e}=j();return Kt=(n,r,s)=>{const i=o(s),c=e(s),a=r[0],l=r[1],d=r[2],u=r[3],h=r[8],f=r[9],v=r[10],m=r[11];return r!==n&&(n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15]),n[0]=a*c-h*i,n[1]=l*c-f*i,n[2]=d*c-v*i,n[3]=u*c-m*i,n[8]=a*i+h*c,n[9]=l*i+f*c,n[10]=d*i+v*c,n[11]=u*i+m*c,n},Kt}var jt,fa;function Bd(){if(fa)return jt;fa=1;const{sin:o,cos:e}=j();return jt=(n,r,s)=>{const i=o(s),c=e(s),a=r[0],l=r[1],d=r[2],u=r[3],h=r[4],f=r[5],v=r[6],m=r[7];return r!==n&&(n[8]=r[8],n[9]=r[9],n[10]=r[10],n[11]=r[11],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15]),n[0]=a*c+h*i,n[1]=l*c+f*i,n[2]=d*c+v*i,n[3]=u*c+m*i,n[4]=h*c-a*i,n[5]=f*c-l*i,n[6]=v*c-d*i,n[7]=m*c-u*i,n},jt}var Jt,ha;function kd(){return ha||(ha=1,Jt=(e,t,n)=>{const r=n[0],s=n[1],i=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=t[7]*s,e[8]=t[8]*i,e[9]=t[9]*i,e[10]=t[10]*i,e[11]=t[11]*i,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}),Jt}var en,da;function Od(){return da||(da=1,en=(e,t,n)=>(e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e)),en}var tn,pa;function Vd(){return pa||(pa=1,tn=e=>e.map(t=>t.toFixed(7)).toString()),tn}var nn,ga;function Ld(){return ga||(ga=1,nn=(e,t,n)=>{const r=n[0],s=n[1],i=n[2];let c,a,l,d,u,h,f,v,m,g,p,y;return t===e?(e[12]=t[0]*r+t[4]*s+t[8]*i+t[12],e[13]=t[1]*r+t[5]*s+t[9]*i+t[13],e[14]=t[2]*r+t[6]*s+t[10]*i+t[14],e[15]=t[3]*r+t[7]*s+t[11]*i+t[15]):(c=t[0],a=t[1],l=t[2],d=t[3],u=t[4],h=t[5],f=t[6],v=t[7],m=t[8],g=t[9],p=t[10],y=t[11],e[0]=c,e[1]=a,e[2]=l,e[3]=d,e[4]=u,e[5]=h,e[6]=f,e[7]=v,e[8]=m,e[9]=g,e[10]=p,e[11]=y,e[12]=c*r+u*s+m*i+t[12],e[13]=a*r+h*s+g*i+t[13],e[14]=l*r+f*s+p*i+t[14],e[15]=d*r+v*s+y*i+t[15]),e}),nn}var rn,va;function Y(){return va||(va=1,rn={add:K1(),clone:j1(),copy:Ji(),create:He(),invert:J1(),equals:ed(),fromRotation:cc(),fromScaling:td(),fromTaitBryanRotation:nd(),fromTranslation:rd(),fromValues:sd(),fromVectorRotation:Rd(),fromXRotation:Sd(),fromYRotation:$d(),fromZRotation:_d(),identity:oc(),isIdentity:bd(),isOnlyTransformScale:Ad(),isMirroring:Md(),mirrorByPlane:Td(),multiply:Fd(),rotate:Cd(),rotateX:Nd(),rotateY:Id(),rotateZ:Bd(),scale:kd(),subtract:Od(),toString:Vd(),translate:Ld()}),rn}var sn,ma;function Dd(){return ma||(ma=1,sn=e=>Object.assign({},e)),sn}var on,ya;function _e(){if(ya)return on;ya=1;const o=Y();return on=t=>(t===void 0&&(t=[]),{sides:t,transforms:o.create()}),on}var cn,xa;function zd(){return xa||(xa=1,cn=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e)),cn}var an,qa;function Gd(){return qa||(qa=1,an=(e,t,n)=>(e[0]=t[0]+n[0],e[1]=t[1]+n[1],e)),an}var ln,wa;function un(){return wa||(wa=1,ln=e=>Math.atan2(e[1],e[0])),ln}var fn,Pa;function Zd(){return Pa||(Pa=1,fn=un()),fn}var hn,Ea;function Yd(){if(Ea)return hn;Ea=1;const o=un();return hn=t=>o(t)*57.29577951308232,hn}var dn,Ra;function be(){return Ra||(Ra=1,dn=()=>[0,0]),dn}var pn,Sa;function Xd(){if(Sa)return pn;Sa=1;const o=be();return pn=t=>{const n=o();return n[0]=t[0],n[1]=t[1],n},pn}var gn,$a;function Hd(){return $a||($a=1,gn=(e,t)=>(e[0]=t[0],e[1]=t[1],e)),gn}var vn,_a;function Ud(){return _a||(_a=1,vn=(e,t,n)=>(e[0]=0,e[1]=0,e[2]=t[0]*n[1]-t[1]*n[0],e)),vn}var mn,ba;function Wd(){return ba||(ba=1,mn=(e,t)=>{const n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)}),mn}var yn,Aa;function Qd(){return Aa||(Aa=1,yn=(e,t,n)=>(e[0]=t[0]/n[0],e[1]=t[1]/n[1],e)),yn}var xn,Ma;function Kd(){return Ma||(Ma=1,xn=(e,t)=>e[0]*t[0]+e[1]*t[1]),xn}var qn,Ta;function jd(){return Ta||(Ta=1,qn=(e,t)=>e[0]===t[0]&&e[1]===t[1]),qn}var wn,Fa;function Ca(){if(Fa)return wn;Fa=1;const{sin:o,cos:e}=j();return wn=(n,r)=>(n[0]=e(r),n[1]=o(r),n),wn}var Pn,Na;function Jd(){if(Na)return Pn;Na=1;const o=Ca();return Pn=(t,n)=>o(t,n*.017453292519943295),Pn}var En,Ia;function ep(){return Ia||(Ia=1,En=(e,t)=>(e[0]=t,e[1]=t,e)),En}var Rn,Ba;function tp(){if(Ba)return Rn;Ba=1;const o=be();return Rn=(t,n)=>{const r=o();return r[0]=t,r[1]=n,r},Rn}var Sn,ka;function np(){return ka||(ka=1,Sn=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1])),Sn}var $n,Oa;function rp(){return Oa||(Oa=1,$n=(e,t,n,r)=>{const s=t[0],i=t[1];return e[0]=s+r*(n[0]-s),e[1]=i+r*(n[1]-i),e}),$n}var _n,Va;function sp(){return Va||(Va=1,_n=(e,t,n)=>(e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e)),_n}var bn,La;function op(){return La||(La=1,bn=(e,t,n)=>(e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e)),bn}var An,Da;function ip(){return Da||(Da=1,An=(e,t,n)=>(e[0]=t[0]*n[0],e[1]=t[1]*n[1],e)),An}var Mn,za;function cp(){return za||(za=1,Mn=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e)),Mn}var Tn,Ga;function Za(){return Ga||(Ga=1,Tn=(e,t,n,r)=>{const s=t[0]-n[0],i=t[1]-n[1],c=Math.cos(r),a=Math.sin(r);return e[0]=s*c-i*a+n[0],e[1]=s*a+i*c+n[1],e}),Tn}var Fn,Ya;function ap(){if(Ya)return Fn;Ya=1;const{TAU:o}=z(),e=be(),t=Za();return Fn=(r,s)=>t(r,s,e(),o/4),Fn}var Cn,Xa;function lp(){return Xa||(Xa=1,Cn=(e,t)=>{const n=t[0],r=t[1];let s=n*n+r*r;return s>0&&(s=1/Math.sqrt(s)),e[0]=n*s,e[1]=r*s,e}),Cn}var Nn,Ha;function up(){return Ha||(Ha=1,Nn=(e,t,n)=>(e[0]=t[0]*n,e[1]=t[1]*n,e)),Nn}var In,Ua;function fp(){return Ua||(Ua=1,In=(e,t,n)=>(e[0]=Math.round(t[0]/n)*n+0,e[1]=Math.round(t[1]/n)*n+0,e)),In}var Bn,Wa;function hp(){return Wa||(Wa=1,Bn=(e,t)=>{const n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r}),Bn}var kn,Qa;function dp(){return Qa||(Qa=1,kn=e=>{const t=e[0],n=e[1];return t*t+n*n}),kn}var On,Ka;function pp(){return Ka||(Ka=1,On=(e,t,n)=>(e[0]=t[0]-n[0],e[1]=t[1]-n[1],e)),On}var Vn,ja;function gp(){return ja||(ja=1,Vn=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`),Vn}var Ln,Ja;function vp(){return Ja||(Ja=1,Ln=(e,t,n)=>{const r=t[0],s=t[1];return e[0]=n[0]*r+n[4]*s+n[12],e[1]=n[1]*r+n[5]*s+n[13],e}),Ln}var Dn,el;function O(){return el||(el=1,Dn={abs:zd(),add:Gd(),angle:Zd(),angleDegrees:Yd(),angleRadians:un(),clone:Xd(),copy:Hd(),create:be(),cross:Ud(),distance:Wd(),divide:Qd(),dot:Kd(),equals:jd(),fromAngleDegrees:Jd(),fromAngleRadians:Ca(),fromScalar:ep(),fromValues:tp(),length:np(),lerp:rp(),max:sp(),min:op(),multiply:ip(),negate:cp(),normal:ap(),normalize:lp(),rotate:Za(),scale:up(),snap:fp(),squaredDistance:hp(),squaredLength:dp(),subtract:pp(),toString:gp(),transform:vp()}),Dn}var zn,tl;function mp(){if(tl)return zn;tl=1;const o=O(),e=_e();return zn=n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");let r=n.length;if(r<3)throw new Error("the given points must define a closed geometry with three or more points");o.equals(n[0],n[r-1])&&--r;const s=[];let i=n[r-1];for(let c=0;c<r;c++){const a=n[c];s.push([o.clone(i),o.clone(a)]),i=a}return e(s)},zn}var Gn,nl;function yp(){if(nl)return Gn;nl=1;const o=Y(),e=O(),t=_e();return Gn=r=>{if(r[0]!==0)throw new Error("invalid compact binary data");const s=t();s.transforms=o.clone(r.slice(1,17));for(let i=21;i<r.length;i+=4){const c=e.fromValues(r[i+0],r[i+1]),a=e.fromValues(r[i+2],r[i+3]);s.sides.push([c,a])}return r[17]>=0&&(s.color=[r[17],r[18],r[19],r[20]]),s},Gn}var Zn,rl;function sl(){return rl||(rl=1,Zn=e=>!!(e&&typeof e=="object"&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms)),Zn}var Yn,ol;function xp(){if(ol)return Yn;ol=1;const o=Y(),e=O();return Yn=n=>(o.isIdentity(n.transforms)||(n.sides=n.sides.map(r=>{const s=e.transform(e.create(),r[0],n.transforms),i=e.transform(e.create(),r[1],n.transforms);return[s,i]}),n.transforms=o.create()),n),Yn}var Xn,il;function ye(){if(il)return Xn;il=1;const o=xp();return Xn=t=>o(t).sides,Xn}var Hn,cl;function al(){if(cl)return Hn;cl=1;const o=_e(),e=ye();return Hn=n=>{const s=e(n).map(i=>[i[1],i[0]]);return s.reverse(),o(s)},Hn}var Un,ll;function ul(){if(ll)return Un;ll=1;const o=O(),e=ye(),t=i=>{const c=new Map,a=l=>{const d=l.toString();return c.has(d)?c.get(d):(c.set(d,l),l)};return i.map(l=>l.map(a))},n=i=>{const c=new Map;return t(i).forEach(l=>{c.has(l[0])?c.get(l[0]).push(l):c.set(l[0],[l])}),c},r=i=>{const c=n(e(i)),a=[];for(;;){let l;for(const[h,f]of c){if(l=f.shift(),!l){c.delete(h);continue}break}if(l===void 0)break;const d=[],u=l[0];for(;;){d.push(l[0]);const h=l[1];if(h===u)break;const f=c.get(h);if(!f)throw new Error(`geometry is not closed at vertex ${h}`);const v=s(l,f);f.length===0&&c.delete(h),l=v}d.length>0&&d.push(d.shift()),a.push(d)}return c.clear(),a},s=(i,c)=>{if(c.length===1)return c.pop();const a=o.create(),l=o.angleDegrees(o.subtract(a,i[1],i[0]));let d,u;c.forEach((f,v)=>{let g=o.angleDegrees(o.subtract(a,f[1],f[0]))-l;g<-180&&(g+=360),g>=180&&(g-=360),(u===void 0||g>d)&&(u=v,d=g)});const h=c[u];return c.splice(u,1),h};return Un=r,Un}var Wn,fl;function qp(){if(fl)return Wn;fl=1;const o=ye();return Wn=t=>{const r=o(t).map(s=>s[0]);return r.length>0&&r.push(r.shift()),r},Wn}var Qn,hl;function wp(){if(hl)return Qn;hl=1;const o=O(),e=ye();return Qn=n=>{const r=e(n);let s="geom2 ("+r.length+` sides):
[
`;return r.forEach(i=>{s+="  ["+o.toString(i[0])+", "+o.toString(i[1])+`]
`}),s+=`]
`,s},Qn}var Kn,dl;function Pp(){return dl||(dl=1,Kn=e=>{const t=e.sides,n=e.transforms;let r=[-1,-1,-1,-1];e.color&&(r=e.color);const s=new Float32Array(21+t.length*4);s[0]=0,s[1]=n[0],s[2]=n[1],s[3]=n[2],s[4]=n[3],s[5]=n[4],s[6]=n[5],s[7]=n[6],s[8]=n[7],s[9]=n[8],s[10]=n[9],s[11]=n[10],s[12]=n[11],s[13]=n[12],s[14]=n[13],s[15]=n[14],s[16]=n[15],s[17]=r[0],s[18]=r[1],s[19]=r[2],s[20]=r[3];for(let i=0;i<t.length;i++){const c=i*4+21,a=t[i][0],l=t[i][1];s[c+0]=a[0],s[c+1]=a[1],s[c+2]=l[0],s[c+3]=l[1]}return s}),Kn}var jn,pl;function Ep(){if(pl)return jn;pl=1;const o=Y(),e=al();return jn=(n,r)=>{const s=o.multiply(o.create(),n,r.transforms),i=Object.assign({},r,{transforms:s});return n[0]*n[5]-n[4]*n[1]<0?e(i):i},jn}var Jn,gl;function Rp(){if(gl)return Jn;gl=1;const o=O(),e=sl(),t=ul();return Jn=r=>{if(!e(r))throw new Error("invalid geom2 structure");if(t(r),r.sides.forEach(s=>{if(o.equals(s[0],s[1]))throw new Error(`geom2 self-edge ${s[0]}`)}),!r.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${r.transforms}`)},Jn}var er,vl;function G(){return vl||(vl=1,er={clone:Dd(),create:_e(),fromPoints:mp(),fromCompactBinary:yp(),isA:sl(),reverse:al(),toOutlines:ul(),toPoints:qp(),toSides:ye(),toString:wp(),toCompactBinary:Pp(),transform:Ep(),validate:Rp()}),er}var tr,ml;function Sp(){return ml||(ml=1,tr=e=>Object.assign({},e)),tr}var nr,yl;function xe(){if(yl)return nr;yl=1;const o=Y();return nr=t=>(t===void 0&&(t=[]),{polygons:t,transforms:o.create()}),nr}var rr,xl;function $p(){if(xl)return rr;xl=1;const o=me(),e=$e(),t=Uc(),n=(s,i,c)=>{const a=[],l=[],d=[];e(a,c,i),e(l,s,i);const u=t(o(d,l,a)),h=t(a);if(h===0)throw Error("a and b are the same point");return u/h};return rr=(s,i,c)=>Math.sqrt(n(s,i,c)),rr}var sr,ql;function _p(){if(ql)return sr;ql=1;const o=me(),e=_t(),t=$e();return sr=(r,s,i,c)=>{const a=[0,0,0];return t(r,s,i),t(a,i,c),o(r,r,a),e(r,r)},sr}var or,wl;function bp(){if(wl)return or;wl=1;class o{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(t,n){n.prev=t.prev,n.next=t,n.prev?n.prev.next=n:this.head=n,t.prev=n}insertAfter(t,n){n.prev=t,n.next=t.next,n.next?n.next.prev=n:this.tail=n,t.next=n}add(t){this.head?this.tail.next=t:this.head=t,t.prev=this.tail,t.next=null,this.tail=t}addAll(t){for(this.head?this.tail.next=t:this.head=t,t.prev=this.tail;t.next;)t=t.next;this.tail=t}remove(t){t.prev?t.prev.next=t.next:this.head=t.next,t.next?t.next.prev=t.prev:this.tail=t.prev}removeChain(t,n){t.prev?t.prev.next=n.next:this.head=n.next,n.next?n.next.prev=t.prev:this.tail=t.prev}first(){return this.head}isEmpty(){return!this.head}}return or=o,or}var ir,Pl;function Ap(){if(Pl)return ir;Pl=1;class o{constructor(t,n){this.point=t,this.index=n,this.next=null,this.prev=null,this.face=null}}return ir=o,ir}var cr,El;function Mp(){if(El)return cr;El=1;const o=Rc(),e=Xc();class t{constructor(r,s){this.vertex=r,this.face=s,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?o(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?e(this.tail().point,this.head().point):-1}setOpposite(r){this.opposite=r,r.opposite=this}}return cr=t,cr}var ar,Rl;function Tp(){if(Rl)return ar;Rl=1;const o=gc(),e=wc(),t=me(),n=Re(),r=Tc(),s=_t(),i=Gc(),c=$e(),a=Mp(),l=0,d=1,u=2;class h{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=l,this.edge=null,this.nVertices=0}getEdge(v){if(typeof v!="number")throw Error("requires a number");let m=this.edge;for(;v>0;)m=m.next,v-=1;for(;v<0;)m=m.prev,v+=1;return m}computeNormal(){const v=this.edge,m=v.next;let g=m.next;const p=c([],m.head().point,v.head().point),y=[],q=[];for(this.nVertices=2,this.normal=[0,0,0];g!==v;)e(q,p),c(p,g.head().point,v.head().point),o(this.normal,this.normal,t(y,q,p)),g=g.next,this.nVertices+=1;this.area=r(this.normal),this.normal=i(this.normal,this.normal,1/this.area)}computeNormalMinArea(v){if(this.computeNormal(),this.area<v){let m,g=0,p=this.edge;do{const E=p.lengthSquared();E>g&&(m=p,g=E),p=p.next}while(p!==this.edge);const y=m.tail().point,q=m.head().point,P=c([],q,y),x=Math.sqrt(g);i(P,P,1/x);const w=n(this.normal,P);i(P,P,-w),o(this.normal,this.normal,P),s(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let v=this.edge;do o(this.centroid,this.centroid,v.head().point),v=v.next;while(v!==this.edge);i(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(v){typeof v<"u"?this.computeNormalMinArea(v):this.computeNormal(),this.computeCentroid(),this.offset=n(this.normal,this.centroid)}distanceToPlane(v){return n(this.normal,v)-this.offset}connectHalfEdges(v,m){let g;if(v.opposite.face===m.opposite.face){const p=m.opposite.face;let y;v===this.edge&&(this.edge=m),p.nVertices===3?(y=m.opposite.prev.opposite,p.mark=u,g=p):(y=m.opposite.next,p.edge===y.prev&&(p.edge=y),y.prev=y.prev.prev,y.prev.next=y),m.prev=v.prev,m.prev.next=m,m.setOpposite(y),p.computeNormalAndCentroid()}else v.next=m,m.prev=v;return g}mergeAdjacentFaces(v,m){const g=v.opposite,p=g.face;m.push(p),p.mark=u;let y=v.prev,q=v.next,P=g.prev,x=g.next;for(;y.opposite.face===p;)y=y.prev,x=x.next;for(;q.opposite.face===p;)q=q.next,P=P.prev;let w;for(w=x;w!==P.next;w=w.next)w.face=this;this.edge=q;let E;return E=this.connectHalfEdges(P,q),E&&m.push(E),E=this.connectHalfEdges(y,x),E&&m.push(E),this.computeNormalAndCentroid(),m}collectIndices(){const v=[];let m=this.edge;do v.push(m.head().index),m=m.next;while(m!==this.edge);return v}static createTriangle(v,m,g,p=0){const y=new h,q=new a(v,y),P=new a(m,y),x=new a(g,y);return q.next=x.prev=P,P.next=q.prev=x,x.next=P.prev=q,y.edge=q,y.computeNormalAndCentroid(p),y}}return ar={VISIBLE:l,NON_CONVEX:d,DELETED:u,Face:h},ar}var lr,Sl;function Fp(){if(Sl)return lr;Sl=1;const o=Re(),e=$p(),t=_p(),n=bp(),r=Ap(),{Face:s,VISIBLE:i,NON_CONVEX:c,DELETED:a}=Tp(),l=1,d=2;class u{constructor(f){if(!Array.isArray(f))throw TypeError("input is not a valid array");if(f.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=f.length,this.faces=[],this.newFaces=[],this.claimed=new n,this.unclaimed=new n,this.vertices=[];for(let v=0;v<f.length;v+=1)this.vertices.push(new r(f[v],v));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(f,v){f.face=v,v.outside?this.claimed.insertBefore(v.outside,f):this.claimed.add(f),v.outside=f}removeVertexFromFace(f,v){f===v.outside&&(f.next&&f.next.face===v?v.outside=f.next:v.outside=null),this.claimed.remove(f)}removeAllVerticesFromFace(f){if(f.outside){let v=f.outside;for(;v.next&&v.next.face===f;)v=v.next;return this.claimed.removeChain(f.outside,v),v.next=null,f.outside}}deleteFaceVertices(f,v){const m=this.removeAllVerticesFromFace(f);if(m)if(!v)this.unclaimed.addAll(m);else{let g;for(let p=m;p;p=g)g=p.next,v.distanceToPlane(p.point)>this.tolerance?this.addVertexToFace(p,v):this.unclaimed.add(p)}}resolveUnclaimedPoints(f){let v=this.unclaimed.first();for(let m=v;m;m=v){v=m.next;let g=this.tolerance,p;for(let y=0;y<f.length;y+=1){const q=f[y];if(q.mark===i){const P=q.distanceToPlane(m.point);if(P>g&&(g=P,p=q),g>1e3*this.tolerance)break}}p&&this.addVertexToFace(m,p)}}computeExtremes(){const f=[],v=[],m=[],g=[];let p,y;for(p=0;p<3;p+=1)m[p]=g[p]=this.vertices[0];for(p=0;p<3;p+=1)f[p]=v[p]=this.vertices[0].point[p];for(p=1;p<this.vertices.length;p+=1){const q=this.vertices[p],P=q.point;for(y=0;y<3;y+=1)P[y]<f[y]&&(f[y]=P[y],m[y]=q);for(y=0;y<3;y+=1)P[y]>v[y]&&(v[y]=P[y],g[y]=q)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(f[0]),Math.abs(v[0]))+Math.max(Math.abs(f[1]),Math.abs(v[1]))+Math.max(Math.abs(f[2]),Math.abs(v[2]))),[m,g]}createInitialSimplex(){const f=this.vertices,[v,m]=this.computeExtremes();let g,p,y,q,P=0,x=0;for(y=0;y<3;y+=1){const _=m[y].point[y]-v[y].point[y];_>P&&(P=_,x=y)}const w=v[x],E=m[x];for(P=0,y=0;y<this.vertices.length;y+=1){const _=this.vertices[y];if(_!==w&&_!==E){const S=e(_.point,w.point,E.point);S>P&&(P=S,g=_)}}const R=t([],w.point,E.point,g.point),b=o(w.point,R);for(P=-1,y=0;y<this.vertices.length;y+=1){const _=this.vertices[y];if(_!==w&&_!==E&&_!==g){const S=Math.abs(o(R,_.point)-b);S>P&&(P=S,p=_)}}const M=[];if(o(p.point,R)-b<0)for(M.push(s.createTriangle(w,E,g),s.createTriangle(p,E,w),s.createTriangle(p,g,E),s.createTriangle(p,w,g)),y=0;y<3;y+=1){const _=(y+1)%3;M[y+1].getEdge(2).setOpposite(M[0].getEdge(_)),M[y+1].getEdge(1).setOpposite(M[_+1].getEdge(0))}else for(M.push(s.createTriangle(w,g,E),s.createTriangle(p,w,E),s.createTriangle(p,E,g),s.createTriangle(p,g,w)),y=0;y<3;y+=1){const _=(y+1)%3;M[y+1].getEdge(2).setOpposite(M[0].getEdge((3-y)%3)),M[y+1].getEdge(0).setOpposite(M[_+1].getEdge(1))}for(y=0;y<4;y+=1)this.faces.push(M[y]);for(y=0;y<f.length;y+=1){const _=f[y];if(_!==w&&_!==E&&_!==g&&_!==p){P=this.tolerance;let S;for(q=0;q<4;q+=1){const A=M[q].distanceToPlane(_.point);A>P&&(P=A,S=M[q])}S&&this.addVertexToFace(_,S)}}}reindexFaceAndVertices(){const f=[];for(let v=0;v<this.faces.length;v+=1){const m=this.faces[v];m.mark===i&&f.push(m)}this.faces=f}collectFaces(f){const v=[];for(let m=0;m<this.faces.length;m+=1){if(this.faces[m].mark!==i)throw Error("attempt to include a destroyed face in the hull");const g=this.faces[m].collectIndices();if(f)v.push(g);else for(let p=0;p<g.length-2;p+=1)v.push([g[0],g[p+1],g[p+2]])}return v}nextVertexToAdd(){if(!this.claimed.isEmpty()){let f,v,m=0;const g=this.claimed.first().face;for(v=g.outside;v&&v.face===g;v=v.next){const p=g.distanceToPlane(v.point);p>m&&(m=p,f=v)}return f}}computeHorizon(f,v,m,g){this.deleteFaceVertices(m),m.mark=a;let p;v?p=v.next:p=v=m.getEdge(0);do{const y=p.opposite,q=y.face;q.mark===i&&(q.distanceToPlane(f)>this.tolerance?this.computeHorizon(f,y,q,g):g.push(p)),p=p.next}while(p!==v)}addAdjoiningFace(f,v){const m=s.createTriangle(f,v.tail(),v.head());return this.faces.push(m),m.getEdge(-1).setOpposite(v.opposite),m.getEdge(0)}addNewFaces(f,v){this.newFaces=[];let m,g;for(let p=0;p<v.length;p+=1){const y=v[p],q=this.addAdjoiningFace(f,y);m?q.next.setOpposite(g):m=q,this.newFaces.push(q.face),g=q}m.next.setOpposite(g)}oppositeFaceDistance(f){return f.face.distanceToPlane(f.opposite.face.centroid)}doAdjacentMerge(f,v){let m=f.edge,g=!0,p=0;do{if(p>=f.nVertices)throw Error("merge recursion limit exceeded");const y=m.opposite.face;let q=!1;if(v===d?(this.oppositeFaceDistance(m)>-this.tolerance||this.oppositeFaceDistance(m.opposite)>-this.tolerance)&&(q=!0):f.area>y.area?this.oppositeFaceDistance(m)>-this.tolerance?q=!0:this.oppositeFaceDistance(m.opposite)>-this.tolerance&&(g=!1):this.oppositeFaceDistance(m.opposite)>-this.tolerance?q=!0:this.oppositeFaceDistance(m)>-this.tolerance&&(g=!1),q){const P=f.mergeAdjacentFaces(m,[]);for(let x=0;x<P.length;x+=1)this.deleteFaceVertices(P[x],f);return!0}m=m.next,p+=1}while(m!==f.edge);return g||(f.mark=c),!1}addVertexToHull(f){const v=[];this.unclaimed.clear(),this.removeVertexFromFace(f,f.face),this.computeHorizon(f.point,null,f.face,v),this.addNewFaces(f,v);for(let m=0;m<this.newFaces.length;m+=1){const g=this.newFaces[m];if(g.mark===i)for(;this.doAdjacentMerge(g,l););}for(let m=0;m<this.newFaces.length;m+=1){const g=this.newFaces[m];if(g.mark===c)for(g.mark=i;this.doAdjacentMerge(g,d););}this.resolveUnclaimedPoints(this.newFaces)}build(){let f;for(this.createInitialSimplex();f=this.nextVertexToAdd();)this.addVertexToHull(f);this.reindexFaceAndVertices()}}return lr=u,lr}var ur,$l;function Cp(){if($l)return ur;$l=1;const o=Fp();return ur=(t,n={})=>{const r=new o(t);return r.build(),r.collectFaces(n.skipTriangulation)},ur}var fr,_l;function de(){return _l||(_l=1,fr=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e})),fr}var hr,bl;function Np(){if(bl)return hr;bl=1;const o=de(),e=B();return hr=(...n)=>{let r,s;return n.length===1?(r=o(),s=n[0]):(r=n[0],s=n[1]),r.vertices=s.vertices.map(i=>e.clone(i)),r},hr}var dr,Al;function Ip(){if(Al)return dr;Al=1;const o=B(),e=de();return dr=n=>{const r=n.map(s=>o.clone(s));return e(r)},dr}var pr,Ml;function Bp(){if(Ml)return pr;Ml=1;const o=de();return pr=(t,n)=>{const r=o(t);return r.plane=n,r},pr}var gr,Tl;function Ae(){return Tl||(Tl=1,gr=()=>[0,0,0,0]),gr}var vr,Fl;function Cl(){if(Fl)return vr;Fl=1;const o=Ae();return vr=t=>{const n=o();return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},vr}var mr,Nl;function Il(){return Nl||(Nl=1,mr=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e)),mr}var yr,Bl;function kl(){return Bl||(Bl=1,yr=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]),yr}var xr,Ol;function Vl(){return Ol||(Ol=1,xr=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e)),xr}var qr,Ll;function Dl(){if(Ll)return qr;Ll=1;const o=B();return qr=(t,n,r)=>{const s=o.normalize(o.create(),n),i=o.dot(r,s);return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=i,t},qr}var wr,zl;function Gl(){if(zl)return wr;zl=1;const o=Ae();return wr=(t,n,r,s)=>{const i=o();return i[0]=t,i[1]=n,i[2]=r,i[3]=s,i},wr}var Pr,Zl;function kp(){if(Zl)return Pr;Zl=1;const o=B(),e=Dl();return Pr=(n,...r)=>{n[0]=0,n[1]=0,n[2]=0,n[3]=0;const s=r.length;r.forEach(g=>{o.add(n,n,g)}),o.scale(n,n,1/s);let i=0,c=0,a=0,l=0,d=0,u=0;const h=o.create();r.forEach(g=>{o.subtract(h,g,n),i+=h[0]*h[0],c+=h[0]*h[1],a+=h[0]*h[2],l+=h[1]*h[1],d+=h[1]*h[2],u+=h[2]*h[2]}),i/=s,c/=s,a/=s,l/=s,d/=s,u/=s,h[0]=0,h[1]=0,h[2]=0;const f=o.create();let v=l*u-d*d;f[0]=v,f[1]=a*d-c*u,f[2]=c*d-a*l;let m=v*v;return o.add(h,h,o.scale(f,f,m)),v=i*u-a*a,f[0]=a*d-c*u,f[1]=v,f[2]=c*a-d*i,m=v*v,o.dot(h,f)<0&&(m=-m),o.add(h,h,o.scale(f,f,m)),v=i*l-c*c,f[0]=c*d-a*l,f[1]=c*a-d*i,f[2]=v,m=v*v,o.dot(h,f)<0&&(m=-m),o.add(h,h,o.scale(f,f,m)),e(n,h,n)},Pr}var Er,Yl;function Xl(){if(Yl)return Er;Yl=1;const o=B();return Er=(t,...n)=>{const r=n.length,s=o.create(),i=o.create(),c=a=>{const l=n[a],d=n[(a+1)%r],u=n[(a+2)%r];return o.subtract(s,d,l),o.subtract(i,u,l),o.cross(s,s,i),o.normalize(s,s),s};return t[0]=0,t[1]=0,t[2]=0,r===3?o.copy(t,c(0)):(n.forEach((a,l)=>{o.add(t,t,c(l))}),o.normalize(t,t)),t[3]=o.dot(t,n[0]),t},Er}var Rr,Hl;function Op(){if(Hl)return Rr;Hl=1;const{EPS:o}=z(),e=B();return Rr=(n,r,s,i)=>{let c=e.subtract(e.create(),s,r),a=e.subtract(e.create(),i,r);e.length(c)<o&&(c=e.orthogonal(c,a)),e.length(a)<o&&(a=e.orthogonal(a,c));let l=e.cross(e.create(),c,a);e.length(l)<o&&(a=e.orthogonal(a,c),l=e.cross(l,c,a)),l=e.normalize(l,l);const d=e.dot(l,r);return n[0]=l[0],n[1]=l[1],n[2]=l[2],n[3]=d,n},Rr}var Sr,Ul;function Vp(){if(Ul)return Sr;Ul=1;const o=B();return Sr=(t,n)=>{const r=n[0]*t[0]+n[1]*t[1]+n[2]*t[2]-t[3],s=n[0]-r*t[0],i=n[1]-r*t[1],c=n[2]-r*t[2];return o.fromValues(s,i,c)},Sr}var $r,Wl;function Ql(){if(Wl)return $r;Wl=1;const o=B();return $r=(t,n)=>o.dot(t,n)-t[3],$r}var _r,Kl;function jl(){return Kl||(Kl=1,_r=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`),_r}var br,Jl;function Lp(){if(Jl)return br;Jl=1;const o=Y(),e=B(),t=Xl(),n=Vl();return br=(s,i,c)=>{const a=o.isMirroring(c),l=e.orthogonal(e.create(),i),d=e.cross(l,i,l),u=e.cross(e.create(),i,d);let h=e.fromScalar(e.create(),i[3]);e.multiply(h,h,i);let f=e.add(e.create(),h,d),v=e.add(e.create(),h,u);return h=e.transform(h,h,c),f=e.transform(f,f,c),v=e.transform(v,v,c),t(s,h,f,v),a&&n(s,s),s},br}var Ar,eu;function oe(){return eu||(eu=1,Ar={clone:Cl(),copy:Il(),create:Ae(),equals:kl(),flip:Vl(),fromNormalAndPoint:Dl(),fromValues:Gl(),fromNoisyPoints:kp(),fromPoints:Xl(),fromPointsRandom:Op(),projectionOfPoint:Vp(),signedDistanceToPoint:Ql(),toString:jl(),transform:Lp()}),Ar}var Mr,tu;function Dp(){if(tu)return Mr;tu=1;const o=oe(),e=de();return Mr=n=>{const r=n.vertices.slice().reverse(),s=e(r);return n.plane&&(s.plane=o.flip(o.create(),n.plane)),s},Mr}var Tr,nu;function ru(){return nu||(nu=1,Tr=e=>!!(e&&typeof e=="object"&&"vertices"in e&&Array.isArray(e.vertices))),Tr}var Fr,su;function ou(){if(su)return Fr;su=1;const o=oe(),e=B(),t=s=>n(s.vertices),n=s=>{const i=s.length;if(i>2){const c=o.fromPoints(o.create(),...s);let a=s[i-2],l=s[i-1];for(let d=0;d<i;d++){const u=s[d];if(!r(a,l,u,c))return!1;a=l,l=u}}return!0},r=(s,i,c,a)=>{const l=e.cross(e.create(),e.subtract(e.create(),i,s),e.subtract(e.create(),c,i));return e.dot(l,a)>=0};return Fr=t,Fr}var Cr,iu;function Nr(){if(iu)return Cr;iu=1;const o=oe();return Cr=t=>(t.plane||(t.plane=o.fromPoints(o.create(),...t.vertices)),t.plane),Cr}var Ir,cu;function au(){if(cu)return Ir;cu=1;const o=Nr();return Ir=t=>{const n=t.vertices.length;if(n<3)return 0;const r=t.vertices,s=o(t),i=Math.abs(s[0]),c=Math.abs(s[1]),a=Math.abs(s[2]);if(i+c+a===0)return 0;let l=3;i>c&&i>a?l=1:c>a&&(l=2);let d=0,u=0,h=1,f=2;switch(l){case 1:for(h=1;h<n;h++)u=h-1,f=(h+1)%n,d+=r[h][1]*(r[f][2]-r[u][2]);d+=r[0][1]*(r[1][2]-r[n-1][2]),d/=2*s[0];break;case 2:for(h=1;h<n;h++)u=h-1,f=(h+1)%n,d+=r[h][2]*(r[f][0]-r[u][0]);d+=r[0][2]*(r[1][0]-r[n-1][0]),d/=2*s[1];break;case 3:default:for(h=1;h<n;h++)u=h-1,f=(h+1)%n,d+=r[h][0]*(r[f][1]-r[u][1]);d+=r[0][0]*(r[1][1]-r[n-1][1]),d/=2*s[2];break}return d},Ir}var Br,lu;function zp(){if(lu)return Br;lu=1;const o=B();return Br=t=>{const n=t.vertices,r=n.length,s=r===0?o.create():o.clone(n[0]),i=o.clone(s);for(let c=1;c<r;c++)o.min(s,s,n[c]),o.max(i,i,n[c]);return[s,i]},Br}var kr,uu;function Gp(){return uu||(uu=1,kr=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]),kr}var Or,fu;function Zp(){return fu||(fu=1,Or=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e[3]=t,e)),Or}var Vr,hu;function Yp(){return hu||(hu=1,Vr=(e,t,n)=>{const[r,s,i,c]=t;return e[0]=n[0]*r+n[4]*s+n[8]*i+n[12]*c,e[1]=n[1]*r+n[5]*s+n[9]*i+n[13]*c,e[2]=n[2]*r+n[6]*s+n[10]*i+n[14]*c,e[3]=n[3]*r+n[7]*s+n[11]*i+n[15]*c,e}),Vr}var Lr,du;function Xp(){return du||(du=1,Lr={clone:Cl(),copy:Il(),create:Ae(),dot:Gp(),equals:kl(),fromScalar:Zp(),fromValues:Gl(),toString:jl(),transform:Yp()}),Lr}var Dr,pu;function Hp(){if(pu)return Dr;pu=1;const o=Xp(),e=new WeakMap;return Dr=n=>{const r=e.get(n);if(r)return r;const s=n.vertices,i=o.create();if(s.length===0)return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i;let c=s[0],a=c,l=c,d=c,u=c,h=c;s.forEach(g=>{c[0]>g[0]&&(c=g),a[1]>g[1]&&(a=g),l[2]>g[2]&&(l=g),d[0]<g[0]&&(d=g),u[1]<g[1]&&(u=g),h[2]<g[2]&&(h=g)}),i[0]=(c[0]+d[0])*.5,i[1]=(a[1]+u[1])*.5,i[2]=(l[2]+h[2])*.5;const f=i[0]-d[0],v=i[1]-u[1],m=i[2]-h[2];return i[3]=Math.sqrt(f*f+v*v+m*m),e.set(n,i),i},Dr}var zr,gu;function Up(){if(gu)return zr;gu=1;const o=B();return zr=t=>{let n=0;const r=t.vertices,s=o.create();for(let i=0;i<r.length-2;i++)o.cross(s,r[i+1],r[i+2]),n+=o.dot(r[0],s);return n/=6,n},zr}var Gr,vu;function Wp(){return vu||(vu=1,Gr=e=>e.vertices),Gr}var Zr,mu;function Qp(){if(mu)return Zr;mu=1;const o=B();return Zr=t=>{let n="poly3: vertices: [";return t.vertices.forEach(r=>{n+=`${o.toString(r)}, `}),n+="]",n},Zr}var Yr,yu;function Kp(){if(yu)return Yr;yu=1;const o=Y(),e=B(),t=de();return Yr=(r,s)=>{const i=s.vertices.map(c=>e.transform(e.create(),c,r));return o.isMirroring(r)&&i.reverse(),t(i)},Yr}var Xr,xu;function jp(){if(xu)return Xr;xu=1;const o=Ql(),{NEPS:e}=z(),t=B(),n=ru(),r=ou(),s=au(),i=Nr();return Xr=a=>{if(!n(a))throw new Error("invalid poly3 structure");if(a.vertices.length<3)throw new Error(`poly3 not enough vertices ${a.vertices.length}`);if(s(a)<=0)throw new Error("poly3 area must be greater than zero");for(let l=0;l<a.vertices.length;l++)if(t.equals(a.vertices[l],a.vertices[(l+1)%a.vertices.length]))throw new Error(`poly3 duplicate vertex ${a.vertices[l]}`);if(!r(a))throw new Error("poly3 must be convex");if(a.vertices.forEach(l=>{if(!l.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${l}`)}),a.vertices.length>3){const l=i(a);a.vertices.forEach(d=>{const u=Math.abs(o(l,d));if(u>e)throw new Error(`poly3 must be coplanar: vertex ${d} distance ${u}`)})}},Xr}var Hr,qu;function Z(){return qu||(qu=1,Hr={clone:Np(),create:de(),fromPoints:Ip(),fromPointsAndPlane:Bp(),invert:Dp(),isA:ru(),isConvex:ou(),measureArea:au(),measureBoundingBox:zp(),measureBoundingSphere:Hp(),measureSignedVolume:Up(),plane:Nr(),toPoints:Wp(),toString:Qp(),transform:Kp(),validate:jp()}),Hr}var Ur,wu;function Jp(){if(wu)return Ur;wu=1;const o=Cp(),e=xe(),t=Z();return Ur=r=>{if(!Array.isArray(r))throw new Error("the given points must be an array");const i=o(r,{skipTriangulation:!0}).map(c=>{const a=c.map(l=>r[l]);return t.create(a)});return e(i)},Ur}var Wr,Pu;function e0(){if(Pu)return Wr;Pu=1;const o=Z(),e=xe();return Wr=n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");const r=n.map((i,c)=>o.create(i));return e(r)},Wr}var Qr,Eu;function t0(){if(Eu)return Qr;Eu=1;const o=B(),e=Y(),t=Z(),n=xe();return Qr=s=>{if(s[0]!==1)throw new Error("invalid compact binary data");const i=n();i.transforms=e.clone(s.slice(1,17));const c=s[21];let a=22,l=s.length-c*3;for(;l<s.length;){const d=s[a];a++;const u=[];for(let h=0;h<d;h++)u.push(o.fromValues(s[l],s[l+1],s[l+2])),l+=3;i.polygons.push(t.create(u))}return s[17]>=0&&(i.color=[s[17],s[18],s[19],s[20]]),i},Qr}var Kr,Ru;function n0(){if(Ru)return Kr;Ru=1;const o=Y(),e=Z();return Kr=n=>(o.isIdentity(n.transforms)||(n.polygons=n.polygons.map(r=>e.transform(n.transforms,r)),n.transforms=o.create()),n),Kr}var jr,Su;function Me(){if(Su)return jr;Su=1;const o=n0();return jr=t=>o(t).polygons,jr}var Jr,$u;function r0(){if($u)return Jr;$u=1;const o=Z(),e=xe(),t=Me();return Jr=r=>{const i=t(r).map(c=>o.invert(c));return e(i)},Jr}var es,_u;function bu(){return _u||(_u=1,es=e=>!!(e&&typeof e=="object"&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms)),es}var ts,Au;function s0(){if(Au)return ts;Au=1;const o=Z(),e=Me();return ts=n=>e(n).map(i=>o.toPoints(i)),ts}var ns,Mu;function o0(){if(Mu)return ns;Mu=1;const o=Z(),e=Me();return ns=n=>{const r=e(n);let s="geom3 ("+r.length+` polygons):
`;return r.forEach(i=>{s+="  "+o.toString(i)+`
`}),s},ns}var rs,Tu;function i0(){if(Tu)return rs;Tu=1;const o=Z();return rs=t=>{const n=t.polygons,r=t.transforms,s=n.length,i=n.reduce((u,h)=>u+h.vertices.length,0);let c=[-1,-1,-1,-1];t.color&&(c=t.color);const a=new Float32Array(22+s+i*3);a[0]=1,a[1]=r[0],a[2]=r[1],a[3]=r[2],a[4]=r[3],a[5]=r[4],a[6]=r[5],a[7]=r[6],a[8]=r[7],a[9]=r[8],a[10]=r[9],a[11]=r[10],a[12]=r[11],a[13]=r[12],a[14]=r[13],a[15]=r[14],a[16]=r[15],a[17]=c[0],a[18]=c[1],a[19]=c[2],a[20]=c[3],a[21]=i;let l=22,d=l+s;return n.forEach(u=>{const h=o.toPoints(u);a[l]=h.length,l++;for(let f=0;f<h.length;f++){const v=h[f];a[d+0]=v[0],a[d+1]=v[1],a[d+2]=v[2],d+=3}}),a},rs}var ss,Fu;function c0(){if(Fu)return ss;Fu=1;const o=Y();return ss=(t,n)=>{const r=o.multiply(o.create(),t,n.transforms);return Object.assign({},n,{transforms:r})},ss}var os,Cu;function a0(){if(Cu)return os;Cu=1;const o=Z(),e=bu(),t=r=>{if(!e(r))throw new Error("invalid geom3 structure");if(r.polygons.forEach(o.validate),n(r),!r.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${r.transforms}`)},n=r=>{const s=new Map;r.polygons.forEach(({vertices:c})=>{c.forEach((a,l)=>{const d=`${a}`,u=`${c[(l+1)%c.length]}`,h=`${d}/${u}`,f=s.has(h)?s.get(h):0;s.set(h,f+1)})});const i=[];if(s.forEach((c,a)=>{const l=a.split("/").reverse().join("/"),d=s.get(l);c!==d&&i.push(a.replace("/"," -> "))}),i.length>0)throw new Error(`non-manifold edges ${i.length}
${i.join(`
`)}`)};return os=t,os}var is,Nu;function L(){return Nu||(Nu=1,is={clone:Sp(),create:xe(),fromPointsConvex:Jp(),fromPoints:e0(),fromCompactBinary:t0(),invert:r0(),isA:bu(),toPoints:s0(),toPolygons:Me(),toString:o0(),toCompactBinary:i0(),transform:c0(),validate:a0()}),is}var cs,Iu;function Bu(){if(Iu)return cs;Iu=1;const o=oe(),e=B();return cs=n=>{const r=n.edges;if(r.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const s=r.reduce((l,d)=>e.add(e.create(),l,d[0]),e.create());e.scale(s,s,1/r.length);let i,c=0;r.forEach(l=>{if(!e.equals(l[0],l[1])){const d=e.squaredDistance(s,l[0]);d>c&&(i=l,c=d)}});const a=r.find(l=>e.equals(l[1],i[0]));return o.fromPoints(o.create(),a[0],i[0],i[1])},cs}var as,ku;function fe(){return ku||(ku=1,as=e=>(e||(e=[]),{edges:e})),as}var ls,Ou;function l0(){if(Ou)return ls;Ou=1;const o=fe(),e=B();return ls=(...n)=>{let r,s;return n.length===1?(r=o(),s=n[0]):(r=n[0],s=n[1]),r.edges=s.edges.map(i=>[e.clone(i[0]),e.clone(i[1])]),r},ls}var us,Vu;function u0(){if(Vu)return us;Vu=1;const o=B();return us=(t,n)=>{const r=t.edges,s=n.edges;return r.length!==s.length?!1:r.reduce((c,a,l)=>{const d=s[l],u=o.squaredDistance(a[0],d[0]);return c&&u<Number.EPSILON},!0)},us}var fs,Lu;function f0(){if(Lu)return fs;Lu=1;const o=B(),e=fe();return fs=n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");if(n.length<3)throw new Error("the given points must contain THREE or more points");const r=[];let s=n[n.length-1];return n.forEach(i=>{i.length===2&&r.push([o.fromVec2(o.create(),s),o.fromVec2(o.create(),i)]),i.length===3&&r.push([s,i]),s=i}),e(r)},fs}var hs,Du;function h0(){if(Du)return hs;Du=1;const o=B(),e=fe();return hs=n=>{if(!Array.isArray(n))throw new Error("the given sides must be an array");const r=[];return n.forEach(s=>{r.push([o.fromVec2(o.create(),s[0]),o.fromVec2(o.create(),s[1])])}),e(r)},hs}var ds,zu;function d0(){return zu||(zu=1,ds=e=>!!(e&&typeof e=="object"&&"edges"in e&&Array.isArray(e.edges))),ds}var ps,Gu;function p0(){if(Gu)return ps;Gu=1;const o=fe();return ps=(...t)=>{let n,r;return t.length===1?(n=o(),r=t[0]):(n=t[0],r=t[1]),n.edges=r.edges.map(s=>[s[1],s[0]]),n},ps}var gs,Zu;function g0(){return Zu||(Zu=1,gs=e=>e.edges),gs}var vs,Yu;function v0(){return Yu||(Yu=1,vs=(e,t)=>{let n,r,s,i,c,a=1;do{r=e,e=null;let l=null;for(c=0;r;){c++,s=r;let d=0;for(n=0;n<a&&(d++,s=s.nextZ,!!s);n++);let u=a;for(;d>0||u>0&&s;)d!==0&&(u===0||!s||t(r)<=t(s))?(i=r,r=r.nextZ,d--):(i=s,s=s.nextZ,u--),l?l.nextZ=i:e=i,i.prevZ=l,l=i;r=s}l.nextZ=null,a*=2}while(c>1);return e}),vs}var ms,Xu;function Hu(){if(Xu)return ms;Xu=1;const o=v0();class e{constructor(s,i,c){this.i=s,this.x=i,this.y=c,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}return ms={Node:e,insertNode:(r,s,i,c)=>{const a=new e(r,s,i);return c?(a.next=c.next,a.prev=c,c.next.prev=a,c.next=a):(a.prev=a,a.next=a),a},removeNode:r=>{r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)},sortLinked:o},ms}var ys,Uu;function xs(){return Uu||(Uu=1,ys={area:(t,n,r)=>(n.y-t.y)*(r.x-n.x)-(n.x-t.x)*(r.y-n.y),pointInTriangle:(t,n,r,s,i,c,a,l)=>(i-a)*(n-l)-(t-a)*(c-l)>=0&&(t-a)*(s-l)-(r-a)*(n-l)>=0&&(r-a)*(c-l)-(i-a)*(s-l)>=0}),ys}var qs,Wu;function Qu(){if(Wu)return qs;Wu=1;const{Node:o,insertNode:e,removeNode:t}=Hu(),{area:n}=xs(),r=(g,p,y,q,P)=>{let x;if(P===v(g,p,y,q)>0)for(let w=p;w<y;w+=q)x=e(w,g[w],g[w+1],x);else for(let w=y-q;w>=p;w-=q)x=e(w,g[w],g[w+1],x);return x&&m(x,x.next)&&(t(x),x=x.next),x},s=(g,p)=>{if(!g)return g;p||(p=g);let y=g,q;do if(q=!1,!y.steiner&&(m(y,y.next)||n(y.prev,y,y.next)===0)){if(t(y),y=p=y.prev,y===y.next)break;q=!0}else y=y.next;while(q||y!==p);return p},i=(g,p,y)=>{let q=g;do{const P=q.prev,x=q.next.next;!m(P,x)&&h(P,q,q.next,x)&&a(P,x)&&a(x,P)&&(p.push(P.i/y),p.push(q.i/y),p.push(x.i/y),t(q),t(q.next),q=g=x),q=q.next}while(q!==g);return s(q)},c=(g,p)=>{let y=g;do{if(y.i!==g.i&&y.next.i!==g.i&&y.i!==p.i&&y.next.i!==p.i&&h(y,y.next,g,p))return!0;y=y.next}while(y!==g);return!1},a=(g,p)=>n(g.prev,g,g.next)<0?n(g,p,g.next)>=0&&n(g,g.prev,p)>=0:n(g,p,g.prev)<0||n(g,g.next,p)<0,l=(g,p)=>{let y=g,q=!1;const P=(g.x+p.x)/2,x=(g.y+p.y)/2;do y.y>x!=y.next.y>x&&y.next.y!==y.y&&P<(y.next.x-y.x)*(x-y.y)/(y.next.y-y.y)+y.x&&(q=!q),y=y.next;while(y!==g);return q},d=(g,p)=>{const y=new o(g.i,g.x,g.y),q=new o(p.i,p.x,p.y),P=g.next,x=p.prev;return g.next=p,p.prev=g,y.next=P,P.prev=y,q.next=y,y.prev=q,x.next=q,q.prev=x,q},u=(g,p)=>g.next.i!==p.i&&g.prev.i!==p.i&&!c(g,p)&&(a(g,p)&&a(p,g)&&l(g,p)&&(n(g.prev,g,p.prev)||n(g,p.prev,p))||m(g,p)&&n(g.prev,g,g.next)>0&&n(p.prev,p,p.next)>0),h=(g,p,y,q)=>{const P=Math.sign(n(g,p,y)),x=Math.sign(n(g,p,q)),w=Math.sign(n(y,q,g)),E=Math.sign(n(y,q,p));return!!(P!==x&&w!==E||P===0&&f(g,y,p)||x===0&&f(g,q,p)||w===0&&f(y,g,q)||E===0&&f(y,p,q))},f=(g,p,y)=>p.x<=Math.max(g.x,y.x)&&p.x>=Math.min(g.x,y.x)&&p.y<=Math.max(g.y,y.y)&&p.y>=Math.min(g.y,y.y),v=(g,p,y,q)=>{let P=0;for(let x=p,w=y-q;x<y;x+=q)P+=(g[w]-g[x])*(g[x+1]+g[w+1]),w=x;return P},m=(g,p)=>g.x===p.x&&g.y===p.y;return qs={cureLocalIntersections:i,filterPoints:s,isValidDiagonal:u,linkedPolygon:r,locallyInside:a,splitPolygon:d},qs}var ws,Ku;function m0(){if(Ku)return ws;Ku=1;const{filterPoints:o,linkedPolygon:e,locallyInside:t,splitPolygon:n}=Qu(),{area:r,pointInTriangle:s}=xs(),i=(u,h,f,v)=>{const m=[];for(let g=0,p=h.length;g<p;g++){const y=h[g]*v,q=g<p-1?h[g+1]*v:u.length,P=e(u,y,q,v,!1);P===P.next&&(P.steiner=!0),m.push(d(P))}m.sort((g,p)=>g.x-p.x);for(let g=0;g<m.length;g++)f=c(m[g],f),f=o(f,f.next);return f},c=(u,h)=>{const f=a(u,h);if(!f)return h;const v=n(f,u),m=o(f,f.next);return o(v,v.next),h===f?m:h},a=(u,h)=>{let f=h;const v=u.x,m=u.y;let g=-1/0,p;do{if(m<=f.y&&m>=f.next.y&&f.next.y!==f.y){const w=f.x+(m-f.y)*(f.next.x-f.x)/(f.next.y-f.y);if(w<=v&&w>g){if(g=w,w===v){if(m===f.y)return f;if(m===f.next.y)return f.next}p=f.x<f.next.x?f:f.next}}f=f.next}while(f!==h);if(!p)return null;if(v===g)return p;const y=p,q=p.x,P=p.y;let x=1/0;f=p;do{if(v>=f.x&&f.x>=q&&v!==f.x&&s(m<P?v:g,m,q,P,m<P?g:v,m,f.x,f.y)){const w=Math.abs(m-f.y)/(v-f.x);t(f,u)&&(w<x||w===x&&(f.x>p.x||f.x===p.x&&l(p,f)))&&(p=f,x=w)}f=f.next}while(f!==y);return p},l=(u,h)=>r(u.prev,u,h.prev)<0&&r(h.next,u,u.next)<0,d=u=>{let h=u,f=u;do(h.x<f.x||h.x===f.x&&h.y<f.y)&&(f=h),h=h.next;while(h!==u);return f};return ws=i,ws}var Ps,ju;function y0(){if(ju)return Ps;ju=1;const o=m0(),{removeNode:e,sortLinked:t}=Hu(),{cureLocalIntersections:n,filterPoints:r,isValidDiagonal:s,linkedPolygon:i,splitPolygon:c}=Qu(),{area:a,pointInTriangle:l}=xs(),d=(p,y,q=2)=>{const P=y&&y.length,x=P?y[0]*q:p.length;let w=i(p,0,x,q,!0);const E=[];if(!w||w.next===w.prev)return E;let R,b,M,_,S;if(P&&(w=o(p,y,w,q)),p.length>80*q){R=M=p[0],b=_=p[1];for(let A=q;A<x;A+=q){const T=p[A],$=p[A+1];T<R&&(R=T),$<b&&(b=$),T>M&&(M=T),$>_&&(_=$)}S=Math.max(M-R,_-b),S=S!==0?1/S:0}return u(w,E,q,R,b,S),E},u=(p,y,q,P,x,w,E)=>{if(!p)return;!E&&w&&m(p,P,x,w);let R=p,b,M;for(;p.prev!==p.next;){if(b=p.prev,M=p.next,w?f(p,P,x,w):h(p)){y.push(b.i/q),y.push(p.i/q),y.push(M.i/q),e(p),p=M.next,R=M.next;continue}if(p=M,p===R){E?E===1?(p=n(r(p),y,q),u(p,y,q,P,x,w,2)):E===2&&v(p,y,q,P,x,w):u(r(p),y,q,P,x,w,1);break}}},h=p=>{const y=p.prev,q=p,P=p.next;if(a(y,q,P)>=0)return!1;let x=p.next.next;for(;x!==p.prev;){if(l(y.x,y.y,q.x,q.y,P.x,P.y,x.x,x.y)&&a(x.prev,x,x.next)>=0)return!1;x=x.next}return!0},f=(p,y,q,P)=>{const x=p.prev,w=p,E=p.next;if(a(x,w,E)>=0)return!1;const R=x.x<w.x?x.x<E.x?x.x:E.x:w.x<E.x?w.x:E.x,b=x.y<w.y?x.y<E.y?x.y:E.y:w.y<E.y?w.y:E.y,M=x.x>w.x?x.x>E.x?x.x:E.x:w.x>E.x?w.x:E.x,_=x.y>w.y?x.y>E.y?x.y:E.y:w.y>E.y?w.y:E.y,S=g(R,b,y,q,P),A=g(M,_,y,q,P);let T=p.prevZ,$=p.nextZ;for(;T&&T.z>=S&&$&&$.z<=A;){if(T!==p.prev&&T!==p.next&&l(x.x,x.y,w.x,w.y,E.x,E.y,T.x,T.y)&&a(T.prev,T,T.next)>=0||(T=T.prevZ,$!==p.prev&&$!==p.next&&l(x.x,x.y,w.x,w.y,E.x,E.y,$.x,$.y)&&a($.prev,$,$.next)>=0))return!1;$=$.nextZ}for(;T&&T.z>=S;){if(T!==p.prev&&T!==p.next&&l(x.x,x.y,w.x,w.y,E.x,E.y,T.x,T.y)&&a(T.prev,T,T.next)>=0)return!1;T=T.prevZ}for(;$&&$.z<=A;){if($!==p.prev&&$!==p.next&&l(x.x,x.y,w.x,w.y,E.x,E.y,$.x,$.y)&&a($.prev,$,$.next)>=0)return!1;$=$.nextZ}return!0},v=(p,y,q,P,x,w)=>{let E=p;do{let R=E.next.next;for(;R!==E.prev;){if(E.i!==R.i&&s(E,R)){let b=c(E,R);E=r(E,E.next),b=r(b,b.next),u(E,y,q,P,x,w),u(b,y,q,P,x,w);return}R=R.next}E=E.next}while(E!==p)},m=(p,y,q,P)=>{let x=p;do x.z===null&&(x.z=g(x.x,x.y,y,q,P)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next;while(x!==p);x.prevZ.nextZ=null,x.prevZ=null,t(x,w=>w.z)},g=(p,y,q,P,x)=>(p=32767*(p-q)*x,y=32767*(y-P)*x,p=(p|p<<8)&16711935,p=(p|p<<4)&252645135,p=(p|p<<2)&858993459,p=(p|p<<1)&1431655765,y=(y|y<<8)&16711935,y=(y|y<<4)&252645135,y=(y|y<<2)&858993459,y=(y|y<<1)&1431655765,p|y<<1);return Ps=d,Ps}var Es,Ju;function ef(){if(Ju)return Es;Ju=1;const{NEPS:o}=z();return Es=(t,n)=>Math.abs(t[0]-n[0])<=o&&Math.abs(t[1]-n[1])<=o&&Math.abs(t[2]-n[2])<=o,Es}var Rs,tf;function Te(){return tf||(tf=1,Rs=e=>{let t=0;for(let n=0;n<e.length;n++){const r=(n+1)%e.length;t+=e[n][0]*e[r][1],t-=e[r][0]*e[n][1]}return t/2}),Rs}var Ss,nf;function rf(){return nf||(nf=1,Ss=(e,t,n)=>{let r=n-e[1],s=t[1]-e[1];s<0&&(r=-r,s=-s);let i;return r<=0?i=0:r>=s?i=1:s<1e-10?i=.5:i=r/s,e[0]+i*(t[0]-e[0])}),Ss}var $s,sf;function of(){return sf||(sf=1,$s=(e,t,n,r)=>{if(e[0]===t[0]&&e[1]===t[1]||n[0]===r[0]&&n[1]===r[1])return;const s=(r[1]-n[1])*(t[0]-e[0])-(r[0]-n[0])*(t[1]-e[1]);if(Math.abs(s)<Number.MIN_VALUE)return;const i=((r[0]-n[0])*(e[1]-n[1])-(r[1]-n[1])*(e[0]-n[0]))/s,c=((t[0]-e[0])*(e[1]-n[1])-(t[1]-e[1])*(e[0]-n[0]))/s;if(i<0||i>1||c<0||c>1)return;const a=e[0]+i*(t[0]-e[0]),l=e[1]+i*(t[1]-e[1]);return[a,l]}),$s}var _s,cf;function x0(){return cf||(cf=1,_s=(e,t,n,r,s,i)=>{const a=1/(e*r-t*n);let l=s*r-t*i,d=-s*n+e*i;return l*=a,d*=a,[l,d]}),_s}var bs,af;function As(){return af||(af=1,bs={aboutEqualNormals:ef(),area:Te(),cos:j().cos,interpolateBetween2DPointsForY:rf(),intersect:of(),sin:j().sin,solve2Linear:x0()}),bs}var Ms,lf;function uf(){if(lf)return Ms;lf=1;const o=Te();return Ms=t=>o(t.vertices),Ms}var Ts,ff;function hf(){return ff||(ff=1,Ts=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e})),Ts}var Fs,df;function pf(){if(df)return Fs;df=1;const o=hf();return Fs=t=>{const n=t.vertices.slice().reverse();return o(n)},Fs}var Cs,gf;function q0(){if(gf)return Cs;gf=1;const o=uf(),e=pf(),t=(r,s)=>{if(r.length===0)return 0;const i=s.vertices;return i.length<3?0:(o(s)<0&&(s=e(s)),r.reduce((a,l)=>a+n(l,i),0)===r.length?1:0)},n=(r,s)=>{const i=s.length,c=r[0],a=r[1];let l=s[i-1],d=s[0],u=l[1]>a,h=0,f=0;for(let v=i+1;--v;){const m=d[1]>a;if(u!==m){const g=l[0]>c,p=d[0]>c;(g&&p||d[0]-(d[1]-a)*(l[0]-d[0])/(l[1]-d[1])>=c)&&(h=!h)}u=m,l=d,d=s[++f]}return h};return Cs=t,Cs}var Ns,vf;function mf(){return vf||(vf=1,Ns={arePointsInside:q0(),create:hf(),flip:pf(),measureArea:uf()}),Ns}var Is,yf;function w0(){if(yf)return Is;yf=1;const{area:o}=As(),{toOutlines:e}=G(),{arePointsInside:t}=mf(),n=s=>{const i=e(s),c=[],a=[];i.forEach((u,h)=>{const f=o(u);f<0?a.push(h):f>0&&c.push(h)});const l=[],d=[];return c.forEach((u,h)=>{const f=i[u];l[h]=[],a.forEach((v,m)=>{const g=i[v];t([g[0]],{vertices:f})&&(l[h].push(v),d[m]||(d[m]=[]),d[m].push(h))})}),a.forEach((u,h)=>{if(d[h]&&d[h].length>1){const f=r(d[h],v=>l[v].length);d[h].forEach((v,m)=>{m!==f&&(l[v]=l[v].filter(g=>g!==u))})}}),l.map((u,h)=>({solid:i[c[h]],holes:u.map(f=>i[f])}))},r=(s,i)=>{let c,a;return s.forEach((l,d)=>{const u=i(l);(a===void 0||u<a)&&(c=d,a=u)}),c};return Is=n,Is}var Bs,xf;function P0(){if(xf)return Bs;xf=1;const o=G(),e=oe(),t=O(),n=B(),r=Bu(),s=w0();class i{constructor(a){this.plane=r(a);const l=n.orthogonal(n.create(),this.plane),d=n.cross(n.create(),this.plane,l);this.v=n.normalize(d,d),this.u=n.cross(n.create(),this.v,this.plane),this.basisMap=new Map;const u=a.edges.map(f=>f.map(v=>this.to2D(v))),h=o.create(u);this.roots=s(h)}to2D(a){const l=t.fromValues(n.dot(a,this.u),n.dot(a,this.v));return this.basisMap.set(l,a),l}to3D(a){const l=this.basisMap.get(a);if(l)return l;{console.log("Warning: point not in original slice");const d=n.scale(n.create(),this.u,a[0]),u=n.scale(n.create(),this.v,a[1]),h=n.scale(n.create(),e,e[3]),f=n.add(d,d,h);return n.add(u,u,f)}}}return Bs=i,Bs}var ks,qf;function E0(){if(qf)return ks;qf=1;const o=Z(),e=y0(),t=P0();return ks=r=>{const s=new t(r),i=[];return s.roots.forEach(({solid:c,holes:a})=>{let l=c.length;const d=[];a.forEach((m,g)=>{d.push(l),l+=m.length});const u=[c,...a].flat(),h=u.flat(),f=m=>s.to3D(u[m]),v=e(h,d);for(let m=0;m<v.length;m+=3){const g=v.slice(m,m+3).map(f);i.push(o.fromPointsAndPlane(g,s.plane))}}),i},ks}var Os,wf;function R0(){if(wf)return Os;wf=1;const o=B(),e=n=>n.reduce((r,s)=>r+=`[${o.toString(s[0])}, ${o.toString(s[1])}], `,"");return Os=n=>`[${e(n.edges)}]`,Os}var Vs,Pf;function S0(){if(Pf)return Vs;Pf=1;const o=B(),e=fe();return Vs=(n,r)=>{const s=r.edges.map(i=>[o.transform(o.create(),i[0],n),o.transform(o.create(),i[1],n)]);return e(s)},Vs}var Ls,Ef;function pe(){return Ef||(Ef=1,Ls={calculatePlane:Bu(),clone:l0(),create:fe(),equals:u0(),fromPoints:f0(),fromSides:h0(),isA:d0(),reverse:p0(),toEdges:g0(),toPolygons:E0(),toString:R0(),transform:S0()}),Ls}var Ds,Rf;function $0(){if(Rf)return Ds;Rf=1;const o=B(),e=fe();return Ds=n=>{if(!n.edges)return n;let r=n.edges;const s=new Map,i=new Map;r=r.filter(l=>!o.equals(l[0],l[1])),r.forEach(l=>{const d=l[0].toString(),u=l[1].toString();s.set(d,l[0]),s.set(u,l[1]),i.set(d,(i.get(d)||0)+1),i.set(u,(i.get(u)||0)-1)});const c=[],a=[];return i.forEach((l,d)=>{l<0&&c.push(d),l>0&&a.push(d)}),c.forEach(l=>{const d=s.get(l);let u=1/0,h;a.forEach(f=>{const v=s.get(f),m=o.distance(d,v);m<u&&(u=m,h=v)}),console.warn(`slice.repair: repairing vertex gap ${d} to ${h} distance ${u}`),r=r.map(f=>f[0].toString()===l?[h,f[1]]:f[1].toString()===l?[f[0],h]:f)}),e(r)},Ds}var zs,Sf;function _0(){if(Sf)return zs;Sf=1;const{EPS:o}=z(),e=B(),t=Z(),n=pe(),r=(l,d)=>l===d?l:l<d?r(d,l):d===1?1:d===0?l:r(d,l%d),s=(l,d)=>l*d/r(l,d),i=(l,d)=>{const u=l/d.length;if(u===1)return d;const h=e.fromValues(u,u,u),f=[];return d.forEach(v=>{const m=e.subtract(e.create(),v[1],v[0]);e.divide(m,m,h);let g=v[0];for(let p=1;p<=u;++p){const y=e.add(e.create(),g,m);f.push([g,y]),g=y}}),f},c=o*o/2*Math.sin(Math.PI/3);return zs=(l,d)=>{let u=n.toEdges(l),h=n.toEdges(d);if(u.length!==h.length){const v=s(u.length,h.length);v!==u.length&&(u=i(v,u)),v!==h.length&&(h=i(v,h))}const f=[];return u.forEach((v,m)=>{const g=h[m],p=t.create([v[0],v[1],g[1]]),y=t.measureArea(p);Number.isFinite(y)&&y>c&&f.push(p);const q=t.create([v[0],g[1],g[0]]),P=t.measureArea(q);Number.isFinite(P)&&P>c&&f.push(q)}),f},zs}var Gs,$f;function Fe(){if($f)return Gs;$f=1;const o=Y(),e=G(),t=L(),n=Z(),r=pe(),s=$0(),i=_0(),c=(l,d,u)=>{let h=null;return e.isA(u)&&(h=r.fromSides(e.toSides(u))),n.isA(u)&&(h=r.fromPoints(n.toPoints(u))),l===0||l===1?r.transform(o.fromTranslation(o.create(),[0,0,l]),h):null};return Gs=(l,d)=>{const u={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:c},{numberOfSlices:h,capStart:f,capEnd:v,close:m,repair:g,callback:p}=Object.assign({},u,l);if(h<2)throw new Error("numberOfSlices must be 2 or more");g&&(d=s(d));const y=h-1;let q=null,P=null,x=null,w=[];for(let E=0;E<h;E++){const R=p(E/y,E,d);if(R){if(!r.isA(R))throw new Error("the callback function must return slice objects");if(r.toEdges(R).length===0)throw new Error("the callback function must return slices with one or more edges");x&&(w=w.concat(i(x,R))),E===0&&(q=R),E===h-1&&(P=R),x=R}}if(v){const E=r.toPolygons(P);w=w.concat(E)}if(f){const E=r.toPolygons(q).map(n.invert);w=w.concat(E)}return!f&&!v&&m&&!r.equals(P,q)&&(w=w.concat(i(P,q))),t.create(w)},Gs}var Zs,_f;function U(){if(_f)return Zs;_f=1;const o=e=>e.reduce((t,n)=>Array.isArray(n)?t.concat(o(n)):t.concat(n),[]);return Zs=o,Zs}var Ys,bf;function Xs(){return bf||(bf=1,Ys=e=>Object.assign({},e)),Ys}var Hs,Af;function Mf(){if(Af)return Hs;Af=1;const{EPS:o}=z(),e=O(),t=Xs();return Hs=r=>{if(r.isClosed)return r;const s=t(r);if(s.isClosed=!0,s.points.length>1){const i=s.points,c=i[0];let a=i[i.length-1];for(;e.distance(c,a)<o*o&&(i.pop(),i.length!==1);)a=i[i.length-1]}return s},Hs}var Us,Tf;function Ce(){if(Tf)return Us;Tf=1;const o=Y();return Us=t=>(t===void 0&&(t=[]),{points:t,isClosed:!1,transforms:o.create()}),Us}var Ws,Ff;function Qs(){if(Ff)return Ws;Ff=1;const{EPS:o}=z(),e=O(),t=Mf(),n=Ce();return Ws=(s,i)=>{const c={closed:!1};let{closed:a}=Object.assign({},c,s),l=n();if(l.points=i.map(d=>e.clone(d)),l.points.length>1){const d=l.points[0],u=l.points[l.points.length-1];e.distance(d,u)<o*o&&(a=!0)}return a===!0&&(l=t(l)),l},Ws}var Ks,Cf;function b0(){if(Cf)return Ks;Cf=1;const o=Y(),e=O();return Ks=n=>(o.isIdentity(n.transforms)||(n.points=n.points.map(r=>e.transform(e.create(),r,n.transforms)),n.transforms=o.create()),n),Ks}var js,Nf;function ge(){if(Nf)return js;Nf=1;const o=b0();return js=t=>o(t).points,js}var Js,If;function A0(){if(If)return Js;If=1;const{TAU:o}=z(),e=O(),t=Qs(),n=ge();return Js=(s,i)=>{const c={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:a,radius:l,xaxisrotation:d,clockwise:u,large:h,segments:f}=Object.assign({},c,s);if(!Array.isArray(a))throw new Error("endpoint must be an array of X and Y values");if(a.length<2)throw new Error("endpoint must contain X and Y values");if(a=e.clone(a),!Array.isArray(l))throw new Error("radius must be an array of X and Y values");if(l.length<2)throw new Error("radius must contain X and Y values");if(f<4)throw new Error("segments must be four or more");const v=1e5;if(i.isClosed)throw new Error("the given path cannot be closed");const m=n(i);if(m.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let g=l[0],p=l[1];const y=m[m.length-1];g=Math.round(g*v)/v,p=Math.round(p*v)/v,a=e.fromValues(Math.round(a[0]*v)/v,Math.round(a[1]*v)/v);const q=!u;let P=[];if(g===0||p===0)P.push(a);else{g=Math.abs(g),p=Math.abs(p);const w=d,E=Math.cos(w),R=Math.sin(w),b=e.subtract(e.create(),y,a);e.scale(b,b,.5);const M=Math.round((E*b[0]+R*b[1])*v)/v,_=Math.round((-R*b[0]+E*b[1])*v)/v,S=e.fromValues(M,_),A=S[0]*S[0]/(g*g)+S[1]*S[1]/(p*p);if(A>1){const K=Math.sqrt(A);g*=K,p*=K,g=Math.round(g*v)/v,p=Math.round(p*v)/v}let T=Math.sqrt((g*g*p*p-g*g*S[1]*S[1]-p*p*S[0]*S[0])/(g*g*S[1]*S[1]+p*p*S[0]*S[0]));q===h&&(T=-T);const $=e.fromValues(g*S[1]/p,-p*S[0]/g);e.scale($,$,T);let F=e.fromValues(E*$[0]-R*$[1],R*$[0]+E*$[1]);F=e.add(F,F,e.scale(e.create(),e.add(e.create(),y,a),.5));const C=e.fromValues((S[0]-$[0])/g,(S[1]-$[1])/p),N=e.fromValues((-S[0]-$[0])/g,(-S[1]-$[1])/p),I=e.angleRadians(C);let V=e.angleRadians(N)-I;V=V%o,!q&&V>0?V-=o:q&&V<0&&(V+=o);let H=Math.ceil(Math.abs(V)/o*f)+1;H<1&&(H=1);for(let K=1;K<H;K++){const D=I+K/H*V,se=Math.cos(D),X=Math.sin(D),J=e.fromValues(E*g*se-R*p*X,R*g*se+E*p*X);e.add(J,J,F),P.push(J)}H&&P.push(s.endpoint)}return P=m.concat(P),t({},P)},Js}var eo,Bf;function kf(){if(Bf)return eo;Bf=1;const o=Qs(),e=ge(),{equals:t}=O();return eo=(...r)=>{let s=!1,i=[];return r.forEach((c,a)=>{const l=e(c).slice();if(i.length>0&&l.length>0&&t(l[0],i[i.length-1])&&l.shift(),l.length>0&&s)throw new Error(`Cannot concatenate to a closed path; check the ${a}th path`);s=c.isClosed,i=i.concat(l)}),o({closed:s},i)},eo}var to,Of;function Vf(){if(Of)return to;Of=1;const o=kf(),e=Ce();return to=(n,r)=>o(r,e(n)),to}var no,Lf;function M0(){if(Lf)return no;Lf=1;const{TAU:o}=z(),e=O(),t=O(),n=Vf(),r=ge();return no=(i,c)=>{const a={segments:16};let{controlPoints:l,segments:d}=Object.assign({},a,i);if(!Array.isArray(l))throw new Error("controlPoints must be an array of one or more points");if(l.length<1)throw new Error("controlPoints must be an array of one or more points");if(d<4)throw new Error("segments must be four or more");if(c.isClosed)throw new Error("the given geometry cannot be closed");const u=r(c);if(u.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(l=l.slice(),l[0]===null){if(l.length<2)throw new Error("a null control point must be passed with one more control points");let S=u[u.length-2];if("lastBezierControlPoint"in c&&(S=c.lastBezierControlPoint),!Array.isArray(S))throw new Error("the given path must contain TWO or more points if given a null control point");const A=e.scale(e.create(),u[u.length-1],2);e.subtract(A,A,S),l[0]=A}l.unshift(u[u.length-1]);const f=l.length-1,v=[];let m=1;for(let S=0;S<=f;++S)S>0&&(m*=S),v.push(m);const g=[];for(let S=0;S<=f;++S){const A=v[f]/(v[S]*v[f-S]);g.push(A)}const p=e.create(),y=e.create(),q=t.create(),P=S=>{let A=1,T=Math.pow(1-S,f);const $=S!==1?1/(1-S):1,F=e.create();for(let C=0;C<=f;++C){C===f&&(T=1);const N=g[C]*A*T,I=e.scale(p,l[C],N);e.add(F,F,I),A*=S,T*=$}return F},x=[],w=[],E=f+1;for(let S=0;S<E;++S){const A=S/(E-1),T=P(A);x.push(T),w.push(A)}let R=1;const b=o/d,M=Math.sin(b);for(;R<x.length-1;){const S=e.subtract(p,x[R],x[R-1]);e.normalize(S,S);const A=e.subtract(y,x[R+1],x[R]);e.normalize(A,A);const T=e.cross(q,S,A);if(Math.abs(T[2])>M){const $=w[R-1],F=w[R+1],C=$+(F-$)*1/3,N=$+(F-$)*2/3,I=P(C),k=P(N);x.splice(R,1,I,k),w.splice(R,1,C,N),R--,R<1&&(R=1)}else++R}x.shift();const _=n(x,c);return _.lastBezierControlPoint=l[l.length-2],_},no}var ro,Df;function T0(){if(Df)return ro;Df=1;const o=O(),e=ge();return ro=(n,r)=>{if(n.isClosed!==r.isClosed||n.points.length!==r.points.length)return!1;const s=e(n),i=e(r),c=s.length;let a=0;do{let l=!1;for(let d=0;d<c;d++)if(!o.equals(s[d],i[(d+a)%c])){l=!0;break}if(l===!1)return!0;if(!n.isClosed)return!1}while(++a<c);return!1},ro}var so,zf;function F0(){if(zf)return so;zf=1;const o=Y(),e=O(),t=Ce();return so=r=>{if(r[0]!==2)throw new Error("invalid compact binary data");const s=t();s.transforms=o.clone(r.slice(1,17)),s.isClosed=!!r[17];for(let i=22;i<r.length;i+=2){const c=e.fromValues(r[i],r[i+1]);s.points.push(c)}return r[18]>=0&&(s.color=[r[18],r[19],r[20],r[21]]),s},so}var oo,Gf;function Zf(){return Gf||(Gf=1,oo=e=>!!(e&&typeof e=="object"&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms)),oo}var io,Yf;function C0(){if(Yf)return io;Yf=1;const o=Xs();return io=t=>{const n=o(t);return n.points=t.points.slice().reverse(),n},io}var co,Xf;function N0(){if(Xf)return co;Xf=1;const o=O(),e=ge();return co=n=>{const r=e(n);let s="path ("+r.length+" points, "+n.isClosed+`):
[
`;return r.forEach(i=>{s+="  "+o.toString(i)+`,
`}),s+=`]
`,s},co}var ao,Hf;function I0(){return Hf||(Hf=1,ao=e=>{const t=e.points,n=e.transforms;let r=[-1,-1,-1,-1];e.color&&(r=e.color);const s=new Float32Array(22+t.length*2);s[0]=2,s[1]=n[0],s[2]=n[1],s[3]=n[2],s[4]=n[3],s[5]=n[4],s[6]=n[5],s[7]=n[6],s[8]=n[7],s[9]=n[8],s[10]=n[9],s[11]=n[10],s[12]=n[11],s[13]=n[12],s[14]=n[13],s[15]=n[14],s[16]=n[15],s[17]=e.isClosed?1:0,s[18]=r[0],s[19]=r[1],s[20]=r[2],s[21]=r[3];for(let i=0;i<t.length;i++){const c=i*2+22,a=t[i];s[c]=a[0],s[c+1]=a[1]}return s}),ao}var lo,Uf;function B0(){if(Uf)return lo;Uf=1;const o=Y();return lo=(t,n)=>{const r=o.multiply(o.create(),t,n.transforms);return Object.assign({},n,{transforms:r})},lo}var uo,Wf;function k0(){if(Wf)return uo;Wf=1;const o=O(),e=Zf();return uo=n=>{if(!e(n))throw new Error("invalid path2 structure");if(n.points.length>1){for(let r=0;r<n.points.length;r++)if(o.equals(n.points[r],n.points[(r+1)%n.points.length]))throw new Error(`path2 duplicate points ${n.points[r]}`)}if(n.points.forEach(r=>{if(!r.every(Number.isFinite))throw new Error(`path2 invalid point ${r}`)}),!n.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${n.transforms}`)},uo}var fo,Qf;function te(){return Qf||(Qf=1,fo={appendArc:A0(),appendBezier:M0(),appendPoints:Vf(),clone:Xs(),close:Mf(),concat:kf(),create:Ce(),equals:T0(),fromPoints:Qs(),fromCompactBinary:F0(),isA:Zf(),reverse:C0(),toPoints:ge(),toString:N0(),toCompactBinary:I0(),transform:B0(),validate:k0()}),fo}var ho,Kf;function Ne(){if(Kf)return ho;Kf=1;const o=Y(),e=B(),t=G(),n=pe(),r=Fe();return ho=(i,c)=>{const a={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:l,twistAngle:d,twistSteps:u,repair:h}=Object.assign({},a,i);if(u<1)throw new Error("twistSteps must be 1 or more");d===0&&(u=1);const f=e.clone(l),v=t.toSides(c);if(v.length===0)throw new Error("the given geometry cannot be empty");const m=n.fromSides(v);f[2]<0&&n.reverse(m,m);const g=o.create(),p=(y,q,P)=>{const x=q/u*d,w=e.scale(e.create(),f,q/u);return o.multiply(g,o.fromZRotation(g,x),o.fromTranslation(o.create(),w)),n.transform(g,P)};return i={numberOfSlices:u+1,capStart:!0,capEnd:!0,repair:h,callback:p},r(i,m)},ho}var po,jf;function O0(){if(jf)return po;jf=1;const o=G(),e=te(),t=Ne();return po=(r,s)=>{if(!s.isClosed)throw new Error("extruded path must be closed");const i=e.toPoints(s),c=o.fromPoints(i);return t(r,c)},po}var go,Jf;function V0(){if(Jf)return go;Jf=1;const o=U(),e=G(),t=te(),n=Ne(),r=O0();return go=(i,...c)=>{const a={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:l,twistAngle:d,twistSteps:u,repair:h}=Object.assign({},a,i);if(c=o(c),c.length===0)throw new Error("wrong number of arguments");i={offset:[0,0,l],twistAngle:d,twistSteps:u,repair:h};const f=c.map(v=>t.isA(v)?r(i,v):e.isA(v)?n(i,v):v);return f.length===1?f[0]:f},go}var vo,eh;function mo(){return eh||(eh=1,vo=()=>[0,1,0]),vo}var yo,th;function L0(){if(th)return yo;th=1;const o=mo();return yo=t=>{const n=o();return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},yo}var xo,nh;function qo(){if(nh)return xo;nh=1;const o=O();return xo=t=>{const n=o.normal(o.create(),t);return o.negate(n,n),n},xo}var wo,rh;function Ie(){if(rh)return wo;rh=1;const o=O();return wo=t=>o.scale(o.create(),t,t[2]),wo}var Po,sh;function D0(){if(sh)return Po;sh=1;const o=O(),e=qo(),t=Ie();return Po=(r,s)=>{const i=t(r),c=e(r),a=o.subtract(o.create(),s,i),l=o.dot(a,c);return o.scale(a,c,l),o.add(a,a,i),a},Po}var Eo,oh;function ih(){return oh||(oh=1,Eo=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e)),Eo}var Ro,ch;function z0(){if(ch)return Ro;ch=1;const o=O();return Ro=(t,n)=>{let r=o.dot(n,t);return r=Math.abs(r-t[2]),r},Ro}var So,ah;function G0(){return ah||(ah=1,So=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]),So}var $o,lh;function uh(){if(lh)return $o;lh=1;const o=O();return $o=(t,n,r)=>{const s=o.subtract(o.create(),r,n);o.normal(s,s),o.normalize(s,s);const i=o.dot(n,s);return t[0]=s[0],t[1]=s[1],t[2]=i,t},$o}var _o,fh;function hh(){if(fh)return _o;fh=1;const o=mo();return _o=(t,n,r)=>{const s=o();return s[0]=t,s[1]=n,s[2]=r,s},_o}var bo,dh;function Z0(){if(dh)return bo;dh=1;const o=O(),{solve2Linear:e}=As();return bo=(n,r)=>{const s=e(n[0],n[1],r[0],r[1],n[2],r[2]);return o.clone(s)},bo}var Ao,ph;function Y0(){if(ph)return Ao;ph=1;const o=O(),e=ih(),t=hh();return Ao=(r,s)=>{const i=o.negate(o.create(),s),c=-s[2];return e(r,t(i[0],i[1],c))},Ao}var Mo,gh;function X0(){return gh||(gh=1,Mo=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`),Mo}var To,vh;function H0(){if(vh)return To;vh=1;const o=O(),e=uh(),t=Ie(),n=qo();return To=(s,i,c)=>{const a=t(i),l=n(i);return o.transform(a,a,c),o.transform(l,l,c),e(s,a,l)},To}var Fo,mh;function U0(){if(mh)return Fo;mh=1;const o=Ie();return Fo=(t,n)=>{let r=(t[2]-t[1]*n)/t[0];return Number.isNaN(r)&&(r=o(t)[0]),r},Fo}var Co,yh;function xh(){return yh||(yh=1,Co={clone:L0(),closestPoint:D0(),copy:ih(),create:mo(),direction:qo(),distanceToPoint:z0(),equals:G0(),fromPoints:uh(),fromValues:hh(),intersectPointOfLines:Z0(),origin:Ie(),reverse:Y0(),toString:X0(),transform:H0(),xAtY:U0()}),Co}var No,qh;function wh(){if(qh)return No;qh=1;const{EPS:o,TAU:e}=z(),t=of(),n=xh(),r=O(),s=Te();return No=(c,a)=>{const l={delta:1,corners:"edge",closed:!1,segments:16};let{delta:d,corners:u,closed:h,segments:f}=Object.assign({},l,c);if(Math.abs(d)<o)return a;let v=c.closed?s(a):1;v===0&&(v=1);const m=v>0&&d>=0||v<0&&d<0;d=Math.abs(d);let g=null,p=[];const y=[],q=r.create(),P=a.length;for(let x=0;x<P;x++){const w=(x+1)%P,E=a[x],R=a[w];m?r.subtract(q,E,R):r.subtract(q,R,E),r.normal(q,q),r.normalize(q,q),r.scale(q,q,d);const b=r.add(r.create(),E,q),M=r.add(r.create(),R,q),_=[b,M];if(g!=null&&(h||!h&&w!==0)){const S=t(g[0],g[1],_[0],_[1]);S?(p.pop(),_[0]=S):y.push({c:E,s0:g,s1:_})}g=[b,M],!(w===0&&!h)&&(p.push(_[0]),p.push(_[1]))}if(h&&g!=null){const x=p[0],w=p[1],E=t(g[0],g[1],x,w);if(E)p[0]=E,p.pop();else{const R=a[0],b=[x,w];y.push({c:R,s0:g,s1:b})}}if(u==="edge"){const x=new Map;p.forEach((R,b)=>x.set(R,b));const w=n.create(),E=n.create();y.forEach(R=>{n.fromPoints(w,R.s0[0],R.s0[1]),n.fromPoints(E,R.s1[0],R.s1[1]);const b=n.intersectPointOfLines(w,E);if(Number.isFinite(b[0])&&Number.isFinite(b[1])){const M=R.s0[1],_=x.get(M);p[_]=b,p[(_+1)%p.length]=void 0}else{const M=R.s1[0],_=x.get(M);p[_]=void 0}}),p=p.filter(R=>R!==void 0)}if(u==="round"){let x=Math.floor(f/4);const w=r.create();y.forEach(E=>{let R=r.angle(r.subtract(w,E.s1[0],E.c));if(R-=r.angle(r.subtract(w,E.s0[1],E.c)),m&&R<0&&(R=R+Math.PI,R<0&&(R=R+Math.PI)),!m&&R>0&&(R=R-Math.PI,R>0&&(R=R-Math.PI)),R!==0){x=Math.floor(f*(Math.abs(R)/e));const b=R/x,M=r.angle(r.subtract(w,E.s0[1],E.c)),_=[];for(let S=1;S<x;S++){const A=M+b*S,T=r.fromAngleRadians(r.create(),A);r.scale(T,T,d),r.add(T,T,E.c),_.push(T)}if(_.length>0){const S=E.s0[1];let A=p.findIndex(T=>r.equals(S,T));A=(A+1)%p.length,p.splice(A,0,..._)}}else{const b=E.s1[0],M=p.findIndex(_=>r.equals(b,_));p.splice(M,1)}})}return p},No}var Io,Ph;function W0(){if(Ph)return Io;Ph=1;const o=G(),e=wh();return Io=(n,r)=>{const s={delta:1,corners:"edge",segments:16},{delta:i,corners:c,segments:a}=Object.assign({},s,n);if(!(c==="edge"||c==="chamfer"||c==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const u=o.toOutlines(r).map(h=>(n={delta:i,corners:c,closed:!0,segments:a},e(n,h))).reduce((h,f)=>h.concat(o.toSides(o.fromPoints(f))),[]);return o.create(u)},Io}var Bo,Eh;function Be(){if(Eh)return Bo;Eh=1;const o=G(),e=L(),t=te();return Bo=r=>{let s;for(const i of r){let c=0;if(o.isA(i)&&(c=1),e.isA(i)&&(c=2),t.isA(i)&&(c=3),s&&c!==s)return!1;s=c}return!0},Bo}var ko,Rh;function Q0(){return Rh||(Rh=1,ko={geom2:G(),geom3:L(),path2:te(),poly2:mf(),poly3:Z()}),ko}var Oo,Sh;function K0(){if(Sh)return Oo;Sh=1;const{EPS:o}=z();return Oo=(t,n)=>{let r=0;for(let s=0;s<n;s++)r+=t[1][s]-t[0][s];return o*r/n},Oo}var Vo,$h;function _h(){if($h)return Vo;$h=1;const o=U(),e=O(),t=B(),n=G(),r=L(),s=te(),i=Z(),c=new WeakMap,a=h=>{let f=c.get(h);if(f)return f;const v=s.toPoints(h);let m;v.length===0?m=e.create():m=e.clone(v[0]);let g=e.clone(m);return v.forEach(p=>{e.min(m,m,p),e.max(g,g,p)}),m=[m[0],m[1],0],g=[g[0],g[1],0],f=[m,g],c.set(h,f),f},l=h=>{let f=c.get(h);if(f)return f;const v=n.toPoints(h);let m;v.length===0?m=e.create():m=e.clone(v[0]);let g=e.clone(m);return v.forEach(p=>{e.min(m,m,p),e.max(g,g,p)}),m=[m[0],m[1],0],g=[g[0],g[1],0],f=[m,g],c.set(h,f),f},d=h=>{let f=c.get(h);if(f)return f;const v=r.toPolygons(h);let m=t.create();if(v.length>0){const p=i.toPoints(v[0]);t.copy(m,p[0])}let g=t.clone(m);return v.forEach(p=>{i.toPoints(p).forEach(y=>{t.min(m,m,y),t.max(g,g,y)})}),m=[m[0],m[1],m[2]],g=[g[0],g[1],g[2]],f=[m,g],c.set(h,f),f};return Vo=(...h)=>{if(h=o(h),h.length===0)throw new Error("wrong number of arguments");const f=h.map(v=>s.isA(v)?a(v):n.isA(v)?l(v):r.isA(v)?d(v):[[0,0,0],[0,0,0]]);return f.length===1?f[0]:f},Vo}var Lo,bh;function qe(){if(bh)return Lo;bh=1;const o=U(),{geom2:e,geom3:t,path2:n}=Q0(),r=K0(),s=_h(),i=d=>r(s(d),2),c=d=>r(s(d),2),a=d=>r(s(d),3);return Lo=(...d)=>{if(d=o(d),d.length===0)throw new Error("wrong number of arguments");const u=d.map(h=>n.isA(h)?i(h):e.isA(h)?c(h):t.isA(h)?a(h):0);return u.length===1?u[0]:u},Lo}var Do,Ah;function zo(){if(Ah)return Do;Ah=1;const o=O(),e=G(),t=(r,s)=>{if(s.vertices.length<4)return null;const i=[],c=s.vertices.filter((d,u)=>d[2]>0?(i.push(u),!0):!1);if(c.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const a=c.map(d=>{const u=Math.round(d[0]/r)*r+0,h=Math.round(d[1]/r)*r+0;return o.fromValues(u,h)});if(o.equals(a[0],a[1]))return null;const l=i[1]-i[0];if(l===1||l===3)l===1&&a.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return a};return Do=(r,s)=>{const i=s.map(c=>t(r,c)).filter(c=>c!==null);return e.create(i)},Do}var Go,Mh;function Zo(){if(Mh)return Go;Mh=1;const o=B(),e=G(),t=L(),n=Z(),r=(i,c,a)=>{const l=[o.fromVec2(o.create(),a[0],i),o.fromVec2(o.create(),a[1],i),o.fromVec2(o.create(),a[1],c),o.fromVec2(o.create(),a[0],c)];return n.create(l)};return Go=(i,c)=>{const l=e.toSides(c).map(u=>r(i.z0,i.z1,u));return t.create(l)},Go}var Yo,Th;function j0(){if(Th)return Yo;Th=1;const o=Y(),e=O(),t=B(),n=function(r,s){arguments.length<2&&(s=t.orthogonal(t.create(),r)),this.v=t.normalize(t.create(),t.cross(t.create(),r,s)),this.u=t.cross(t.create(),this.v,r),this.plane=r,this.planeorigin=t.scale(t.create(),r,r[3])};return n.prototype={getProjectionMatrix:function(){return o.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const r=t.scale(t.create(),this.plane,this.plane[3]);return o.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,r[0],r[1],r[2],1)},to2D:function(r){return e.fromValues(t.dot(r,this.u),t.dot(r,this.v))},to3D:function(r){const s=t.scale(t.create(),this.u,r[0]),i=t.scale(t.create(),this.v,r[1]),c=t.add(s,s,this.planeorigin);return t.add(i,i,c)}},Yo=n,Yo}var Xo,Fh;function J0(){return Fh||(Fh=1,Xo=e=>e*.017453292519943295),Xo}var Ho,Ch;function Nh(){return Ch||(Ch=1,Ho=(e,t)=>e-t),Ho}var Uo,Ih;function eg(){return Ih||(Ih=1,Uo=(e,t,n)=>{let r=0,s=e.length;for(;s>r;){const i=Math.floor((r+s)/2),c=e[i];n(t,c)>0?r=i+1:s=i}e.splice(r,0,t)}),Uo}var Wo,Bh;function tg(){if(Bh)return Wo;Bh=1;const{TAU:o}=z();return Wo=(t,n,r)=>{const s=n>0?t*o/n:0,i=r>0?o/r:0;return Math.ceil(Math.max(s,i,4))},Wo}var Qo,kh;function ng(){return kh||(kh=1,Qo=e=>e*57.29577951308232),Qo}var Ko,Oh;function rg(){return Oh||(Oh=1,Ko={areAllShapesTheSameType:Be(),degToRad:J0(),flatten:U(),fnNumberSort:Nh(),insertSorted:eg(),radiusToSegments:tg(),radToDeg:ng()}),Ko}var jo,Vh;function sg(){if(Vh)return jo;Vh=1;const{EPS:o}=z(),e=xh(),t=O(),n=j0(),r=rf(),{insertSorted:s,fnNumberSort:i}=rg(),c=Z();return jo=l=>{if(l.length<2)return l;const d=[],u=l.length,h=c.plane(l[0]),f=new n(h),v=[],m=[],g=new Map,p=new Map,y=new Map,q=10/o;for(let E=0;E<u;E++){const R=l[E];let b=[],M=R.vertices.length,_=-1;if(M>0){let S,A;for(let T=0;T<M;T++){let $=f.to2D(R.vertices[T]);const F=Math.floor($[1]*q);let C;y.has(F)?C=y.get(F):y.has(F+1)?C=y.get(F+1):y.has(F-1)?C=y.get(F-1):(C=$[1],y.set(F,$[1])),$=t.fromValues($[0],C),b.push($);const N=$[1];(T===0||N<S)&&(S=N,_=T),(T===0||N>A)&&(A=N);let I=p.get(N);I||(I={},p.set(N,I)),I[E]=!0}if(S>=A)b=[],M=0,_=-1;else{let T=g.get(S);T||(T=[],g.set(S,T)),T.push(E)}}b.reverse(),_=M-_-1,v.push(b),m.push(_)}const P=[];p.forEach((E,R)=>P.push(R)),P.sort(i);let x=[],w=[];for(let E=0;E<P.length;E++){const R=[],b=P[E],M=p.get(b);for(let S=0;S<x.length;++S){const A=x[S],T=A.polygonindex;if(M[T]){const $=v[T],F=$.length;let C=A.leftvertexindex,N=A.rightvertexindex;for(;;){let k=C+1;if(k>=F&&(k=0),$[k][1]!==b)break;C=k}let I=N-1;if(I<0&&(I=F-1),$[I][1]===b&&(N=I),C!==A.leftvertexindex&&C===N)x.splice(S,1),--S;else{A.leftvertexindex=C,A.rightvertexindex=N,A.topleft=$[C],A.topright=$[N];let k=C+1;k>=F&&(k=0),A.bottomleft=$[k];let V=N-1;V<0&&(V=F-1),A.bottomright=$[V]}}}let _;if(E>=P.length-1)x=[],_=null;else{_=Number(P[E+1]);const S=.5*(b+_),A=g.get(b);for(const T in A){const $=A[T],F=v[$],C=F.length,N=m[$];let I=N;for(;;){let D=I+1;if(D>=C&&(D=0),F[D][1]!==b||D===N)break;I=D}let k=N;for(;;){let D=k-1;if(D<0&&(D=C-1),F[D][1]!==b||D===I)break;k=D}let V=I+1;V>=C&&(V=0);let H=k-1;H<0&&(H=C-1);const K={polygonindex:$,leftvertexindex:I,rightvertexindex:k,topleft:F[I],topright:F[k],bottomleft:F[V],bottomright:F[H]};s(x,K,(D,se)=>{const X=r(D.topleft,D.bottomleft,S),J=r(se.topleft,se.bottomleft,S);return X>J?1:X<J?-1:0})}}for(const S in x){const A=x[S];let T=r(A.topleft,A.bottomleft,b);const $=t.fromValues(T,b);T=r(A.topright,A.bottomright,b);const F=t.fromValues(T,b);T=r(A.topleft,A.bottomleft,_);const C=t.fromValues(T,_);T=r(A.topright,A.bottomright,_);const N=t.fromValues(T,_),I={topleft:$,topright:F,bottomleft:C,bottomright:N,leftline:e.fromPoints(e.create(),$,C),rightline:e.fromPoints(e.create(),N,F)};if(R.length>0){const k=R[R.length-1],V=t.distance(I.topleft,k.topright),H=t.distance(I.bottomleft,k.bottomright);V<o&&H<o&&(I.topleft=k.topleft,I.leftline=k.leftline,I.bottomleft=k.bottomleft,R.splice(R.length-1,1))}R.push(I)}if(E>0){const S=new Set,A=new Set;for(let T=0;T<R.length;T++){const $=R[T];for(let F=0;F<w.length;F++)if(!A.has(F)){const C=w[F];if(t.distance(C.bottomleft,$.topleft)<o&&t.distance(C.bottomright,$.topright)<o){A.add(F);const N=e.direction($.leftline),I=e.direction(C.leftline),k=N[0]-I[0],V=e.direction($.rightline),H=e.direction(C.rightline),K=V[0]-H[0],D=Math.abs(k)<o,se=Math.abs(K)<o,X=D||k>=0,J=se||K>=0;X&&J&&($.outpolygon=C.outpolygon,$.leftlinecontinues=D,$.rightlinecontinues=se,S.add(F));break}}}for(let T=0;T<w.length;T++)if(!S.has(T)){const $=w[T];$.outpolygon.rightpoints.push($.bottomright),t.distance($.bottomright,$.bottomleft)>o&&$.outpolygon.leftpoints.push($.bottomleft),$.outpolygon.leftpoints.reverse();const C=$.outpolygon.rightpoints.concat($.outpolygon.leftpoints).map(I=>f.to3D(I)),N=c.fromPointsAndPlane(C,h);N.vertices.length&&d.push(N)}}for(let S=0;S<R.length;S++){const A=R[S];A.outpolygon?(A.leftlinecontinues||A.outpolygon.leftpoints.push(A.topleft),A.rightlinecontinues||A.outpolygon.rightpoints.push(A.topright)):(A.outpolygon={leftpoints:[],rightpoints:[]},A.outpolygon.leftpoints.push(A.topleft),t.distance(A.topleft,A.topright)>o&&A.outpolygon.rightpoints.push(A.topright))}w=R}return d},jo}var Jo,Lh;function ke(){if(Lh)return Jo;Lh=1;const o=L(),e=Z(),{NEPS:t}=z(),n=sg(),r=c=>{if(c.isRetesselated)return c;const a=o.toPolygons(c).map((h,f)=>({vertices:h.vertices,plane:e.plane(h),index:f})),l=s(a),d=[];l.forEach(h=>{if(Array.isArray(h)){const f=n(h);d.push(...f)}else d.push(h)});const u=o.create(d);return u.isRetesselated=!0,u},s=c=>{let a=[c];const l=[];for(let u=3;u>=0;u--){const h=[],f=u===3?15e-9:t;a.forEach(v=>{v.sort(i(u,f));let m=0;for(let g=1;g<v.length;g++)v[g].plane[u]-v[m].plane[u]>f&&(g-m===1?l.push(v[m]):h.push(v.slice(m,g)),m=g);v.length-m===1?l.push(v[m]):h.push(v.slice(m))}),a=h}const d=[];return a.forEach(u=>{u[0]&&(d[u[0].index]=u)}),l.forEach(u=>{d[u.index]=u}),d},i=(c,a)=>(l,d)=>l.plane[c]-d.plane[c]>a?1:d.plane[c]-l.plane[c]>a?-1:0;return Jo=r,Jo}var ei,Dh;function ti(){if(Dh)return ei;Dh=1;const{EPS:o}=z(),e=_h();return ei=(n,r)=>{if(n.polygons.length===0||r.polygons.length===0)return!1;const s=e(n),i=s[0],c=s[1],a=e(r),l=a[0],d=a[1];return!(l[0]-c[0]>o||i[0]-d[0]>o||l[1]-c[1]>o||i[1]-d[1]>o||l[2]-c[2]>o||i[2]-d[2]>o)},ei}var ni,zh;function og(){if(zh)return ni;zh=1;const o=oe(),e=Z();class t{constructor(r){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=r}invert(){const r=[this];let s;for(let i=0;i<r.length;i++){s=r[i],s.plane&&(s.plane=o.flip(o.create(),s.plane)),s.front&&r.push(s.front),s.back&&r.push(s.back);const c=s.front;s.front=s.back,s.back=c}}clipPolygons(r,s){let i={node:this,polygontreenodes:r},c;const a=[];do{if(c=i.node,r=i.polygontreenodes,c.plane){const l=c.plane,d=[],u=[],h=s?d:u,f=r.length;for(let m=0;m<f;m++){const g=r[m];g.isRemoved()||g.splitByPlane(l,h,d,u,d)}c.front&&u.length>0&&a.push({node:c.front,polygontreenodes:u});const v=d.length;if(c.back&&v>0)a.push({node:c.back,polygontreenodes:d});else for(let m=0;m<v;m++)d[m].remove()}i=a.pop()}while(i!==void 0)}clipTo(r,s){let i=this;const c=[];do i.polygontreenodes.length>0&&r.rootnode.clipPolygons(i.polygontreenodes,s),i.front&&c.push(i.front),i.back&&c.push(i.back),i=c.pop();while(i!==void 0)}addPolygonTreeNodes(r){let s={node:this,polygontreenodes:r};const i=[];do{const c=s.node,a=s.polygontreenodes;if(a.length===0){s=i.pop();continue}if(!c.plane){let h=0;h=Math.floor(a.length/2);const f=a[h].getPolygon();c.plane=e.plane(f)}const l=[],d=[],u=a.length;for(let h=0;h<u;++h)a[h].splitByPlane(c.plane,c.polygontreenodes,d,l,d);l.length>0&&(c.front||(c.front=new t(c)),u===l.length&&d.length===0?c.front.polygontreenodes=l:i.push({node:c.front,polygontreenodes:l})),d.length>0&&(c.back||(c.back=new t(c)),u===d.length&&l.length===0?c.back.polygontreenodes=d:i.push({node:c.back,polygontreenodes:d})),s=i.pop()}while(s!==void 0)}}return ni=t,ni}var ri,Gh;function ig(){if(Gh)return ri;Gh=1;const o=B();return ri=(t,n,r)=>{const s=o.subtract(o.create(),r,n);let i=(t[3]-o.dot(t,n))/o.dot(t,s);return Number.isNaN(i)&&(i=0),i>1&&(i=1),i<0&&(i=0),o.scale(s,s,i),o.add(s,n,s),s},ri}var si,Zh;function cg(){if(Zh)return si;Zh=1;const{EPS:o}=z(),e=oe(),t=B(),n=Z(),r=ig();return si=(i,c)=>{const a={type:null,front:null,back:null},l=c.vertices,d=l.length,u=n.plane(c);if(e.equals(u,i))a.type=0;else{let h=!1,f=!1;const v=[],m=-o;for(let g=0;g<d;g++){const p=t.dot(i,l[g])-i[3],y=p<m;v.push(y),p>o&&(h=!0),p<m&&(f=!0)}if(!h&&!f){const g=t.dot(i,u);a.type=g>=0?0:1}else if(!f)a.type=2;else if(!h)a.type=3;else{a.type=4;const g=[],p=[];let y=v[0];for(let P=0;P<d;P++){const x=l[P];let w=P+1;w>=d&&(w=0);const E=v[w];if(y===E)y?p.push(x):g.push(x);else{const R=l[w],b=r(i,x,R);y?(p.push(x),p.push(b),g.push(b)):(g.push(x),g.push(b),p.push(b))}y=E}const q=o*o;if(p.length>=3){let P=p[p.length-1];for(let x=0;x<p.length;x++){const w=p[x];t.squaredDistance(w,P)<q&&(p.splice(x,1),x--),P=w}}if(g.length>=3){let P=g[g.length-1];for(let x=0;x<g.length;x++){const w=g[x];t.squaredDistance(w,P)<q&&(g.splice(x,1),x--),P=w}}g.length>=3&&(a.front=n.fromPointsAndPlane(g,u)),p.length>=3&&(a.back=n.fromPointsAndPlane(p,u))}}return a},si}var oi,Yh;function ag(){if(Yh)return oi;Yh=1;const{EPS:o}=z(),e=B(),t=Z(),n=cg();class r{constructor(i,c){this.parent=i,this.children=[],this.polygon=c,this.removed=!1}addPolygons(i){if(!this.isRootNode())throw new Error("Assertion failed");const c=this;i.forEach(a=>{c.addChild(a)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const i=this.parent.children,c=i.indexOf(this);if(c<0)throw new Error("Assertion failed");i.splice(c,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(i){let c=[this];const a=[c];let l,d,u,h;for(l=0;l<a.length;++l)for(c=a[l],d=0,u=c.length;d<u;d++)h=c[d],h.polygon?i.push(h.polygon):h.children.length>0&&a.push(h.children)}splitByPlane(i,c,a,l,d){if(this.children.length){const u=[this.children];let h,f,v,m,g;for(h=0;h<u.length;h++)for(g=u[h],f=0,v=g.length;f<v;f++)m=g[f],m.children.length>0?u.push(m.children):m._splitByPlane(i,c,a,l,d)}else this._splitByPlane(i,c,a,l,d)}_splitByPlane(i,c,a,l,d){const u=this.polygon;if(u){const h=t.measureBoundingSphere(u),f=h[3]+o,v=h,m=e.dot(i,v)-i[3];if(m>f)l.push(this);else if(m<-f)d.push(this);else{const g=n(i,u);switch(g.type){case 0:c.push(this);break;case 1:a.push(this);break;case 2:l.push(this);break;case 3:d.push(this);break;case 4:if(g.front){const p=this.addChild(g.front);l.push(p)}if(g.back){const p=this.addChild(g.back);d.push(p)}break}}}}addChild(i){const c=new r(this,i);return this.children.push(c),c}invertSub(){let i=[this];const c=[i];let a,l,d,u;for(a=0;a<c.length;a++)for(i=c[a],l=0,d=i.length;l<d;l++)u=i[l],u.polygon&&(u.polygon=t.invert(u.polygon)),u.children.length>0&&c.push(u.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let i=[this];const c=[i];for(let a=0;a<c.length;++a){i=c[a];const l=i.length;for(let d=0;d<l;d++){const u=i[d];u.polygon&&(u.polygon=null),u.parent&&(u.parent=null),u.children.length>0&&c.push(u.children),u.children=[]}}}toString(){let i="",c=[this];const a=[c];let l,d,u,h;for(l=0;l<a.length;++l){c=a[l];const f=" ".repeat(l);for(d=0,u=c.length;d<u;d++)h=c[d],i+=`${f}PolygonTreeNode (${h.isRootNode()}): ${h.children.length}`,h.polygon?i+=`
 ${f}polygon: ${h.polygon.vertices}
`:i+=`
`,h.children.length>0&&a.push(h.children)}return i}}return oi=r,oi}var ii,Xh;function lg(){if(Xh)return ii;Xh=1;const o=og(),e=ag();class t{constructor(r){this.polygonTree=new e,this.rootnode=new o(null),r&&this.addPolygons(r)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(r,s=!1){this.rootnode.clipTo(r,s)}allPolygons(){const r=[];return this.polygonTree.getPolygons(r),r}addPolygons(r){const s=new Array(r.length);for(let i=0;i<r.length;i++)s[i]=this.polygonTree.addChild(r[i]);this.rootnode.addPolygonTreeNodes(s)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}}return ii=t,ii}var ci,Hh;function ai(){return Hh||(Hh=1,ci={Tree:lg()}),ci}var li,Uh;function Wh(){if(Uh)return li;Uh=1;const o=L(),e=ti(),{Tree:t}=ai(),n=(s,i)=>{if(!e(s,i))return r(s,i);const c=new t(o.toPolygons(s)),a=new t(o.toPolygons(i));c.clipTo(a,!1),a.clipTo(c),a.invert(),a.clipTo(c),a.invert();const l=c.allPolygons().concat(a.allPolygons());return o.create(l)},r=(s,i)=>{let c=o.toPolygons(s);return c=c.concat(o.toPolygons(i)),o.create(c)};return li=n,li}var ui,Qh;function Kh(){if(Qh)return ui;Qh=1;const o=U(),e=ke(),t=Wh();return ui=(...r)=>{r=o(r);let s;for(s=1;s<r.length;s+=2)r.push(t(r[s-1],r[s]));let i=r[s-1];return i=e(i),i},ui}var fi,jh;function Jh(){if(jh)return fi;jh=1;const o=U(),e=L(),t=qe(),n=zo(),r=Zo(),s=Kh();return fi=(...c)=>{c=o(c);const a=c.map(u=>r({z0:-1,z1:1},u)),l=s(a),d=t(l);return n(d,e.toPolygons(l))},fi}var hi,e1;function t1(){if(e1)return hi;e1=1;const o=U(),e=Be(),t=G(),n=L(),r=Jh(),s=Kh();return hi=(...c)=>{if(c=o(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only unions of the same type are supported");const a=c[0];return t.isA(a)?r(c):n.isA(a)?s(c):a},hi}var di,n1;function r1(){return n1||(n1=1,di={isNumberArray:(n,r)=>Array.isArray(n)&&n.length>=r?n.every(s=>Number.isFinite(s)):!1,isGT:(n,r)=>Number.isFinite(n)&&n>r,isGTE:(n,r)=>Number.isFinite(n)&&n>=r}),di}var pi,s1;function ug(){if(s1)return pi;s1=1;const{TAU:o}=z(),e=B(),t=L(),n=Z(),{sin:r,cos:s}=j(),{isGTE:i,isNumberArray:c}=r1();return pi=l=>{const d={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:u,radius:h,segments:f,axes:v}=Object.assign({},d,l);if(!c(u,3))throw new Error("center must be an array of X, Y and Z values");if(!c(h,3))throw new Error("radius must be an array of X, Y and Z values");if(!h.every(E=>E>=0))throw new Error("radius values must be positive");if(!i(f,4))throw new Error("segments must be four or more");if(h[0]===0||h[1]===0||h[2]===0)return t.create();const m=e.scale(e.create(),e.normalize(e.create(),v[0]),h[0]),g=e.scale(e.create(),e.normalize(e.create(),v[1]),h[1]),p=e.scale(e.create(),e.normalize(e.create(),v[2]),h[2]),y=Math.round(f/4);let q;const P=[],x=e.create(),w=e.create();for(let E=0;E<=f;E++){const R=o*E/f,b=e.add(e.create(),e.scale(x,m,s(R)),e.scale(w,g,r(R)));if(E>0){let M,_;for(let S=0;S<=y;S++){const A=o/4*S/y,T=s(A),$=r(A);if(S>0){let F=[],C;C=e.subtract(e.create(),e.scale(x,q,M),e.scale(w,p,_)),F.push(e.add(C,C,u)),C=e.subtract(e.create(),e.scale(x,b,M),e.scale(w,p,_)),F.push(e.add(C,C,u)),S<y&&(C=e.subtract(e.create(),e.scale(x,b,T),e.scale(w,p,$)),F.push(e.add(C,C,u))),C=e.subtract(e.create(),e.scale(x,q,T),e.scale(w,p,$)),F.push(e.add(C,C,u)),P.push(n.create(F)),F=[],C=e.add(e.create(),e.scale(x,q,M),e.scale(w,p,_)),F.push(e.add(e.create(),u,C)),C=e.add(C,e.scale(x,b,M),e.scale(w,p,_)),F.push(e.add(e.create(),u,C)),S<y&&(C=e.add(C,e.scale(x,b,T),e.scale(w,p,$)),F.push(e.add(e.create(),u,C))),C=e.add(C,e.scale(x,q,T),e.scale(w,p,$)),F.push(e.add(e.create(),u,C)),F.reverse(),P.push(n.create(F))}M=T,_=$}}q=b}return t.create(P)},pi}var gi,o1;function fg(){if(o1)return gi;o1=1;const o=ug(),{isGTE:e}=r1();return gi=n=>{const r={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:s,radius:i,segments:c,axes:a}=Object.assign({},r,n);if(!e(i,0))throw new Error("radius must be positive");return i=[i,i,i],o({center:s,radius:i,segments:c,axes:a})},gi}var vi,i1;function hg(){if(i1)return vi;i1=1;const o=Y(),e=B(),t=L(),n=Z();return vi=(s,i)=>{e.dot(n.plane(i),s)>0&&(i=n.invert(i));const a=[i],l=n.transform(o.fromTranslation(o.create(),s),i),d=i.vertices.length;for(let u=0;u<d;u++){const h=u<d-1?u+1:0,f=n.create([i.vertices[u],l.vertices[u],l.vertices[h],i.vertices[h]]);a.push(f)}return a.push(n.invert(l)),t.create(a)},vi}var mi,c1;function dg(){if(c1)return mi;c1=1;const{EPS:o,TAU:e}=z(),t=Y(),n=B(),r=Nh(),s=L(),i=Z(),c=fg(),a=ke(),l=Wh(),d=hg(),u=(m,g,p)=>{const y=g.toString();if(m.has(y))m.get(y)[1].push(p);else{const q=[g,[p]];m.set(y,q)}},h=(m,g,p)=>{const y=g[0].toString(),q=g[1].toString(),P=y<q?`${y},${q}`:`${q},${y}`;if(m.has(P))m.get(P)[1].push(p);else{const x=[g,[p]];m.set(P,x)}},f=(m,g)=>{m.findIndex(y=>y===g)<0&&m.push(g)};return mi=(m,g)=>{const p={delta:1,segments:12},{delta:y,segments:q}=Object.assign({},p,m);let P=s.create();const x=new Map,w=new Map,E=n.create(),R=n.create();return s.toPolygons(g).forEach((M,_)=>{const S=n.scale(n.create(),i.plane(M),2*y),A=i.transform(t.fromTranslation(t.create(),n.scale(n.create(),S,-.5)),M),T=d(S,A);P=l(P,T);const $=M.vertices;for(let F=0;F<$.length;F++){u(x,$[F],i.plane(M));const C=(F+1)%$.length,N=[$[F],$[C]];h(w,N,i.plane(M))}}),w.forEach(M=>{const _=M[0],S=M[1],A=_[0],T=_[1],$=n.subtract(n.create(),T,A);n.normalize($,$);const F=S[0],C=n.cross(n.create(),F,$);let N=[];for(let X=0;X<q;X++)f(N,X*e/q);for(let X=0,J=S.length;X<J;X++){const Ge=S[X],Ze=n.dot(C,Ge),he=n.dot(F,Ge);let re=Math.atan2(Ze,he);re<0&&(re+=e),f(N,re),re=Math.atan2(-Ze,-he),re<0&&(re+=e),f(N,re)}N=N.sort(r);const I=N.length;let k,V;const H=[],K=[],D=[];for(let X=-1;X<I;X++){const J=N[X<0?X+I:X],Ge=Math.sin(J),Ze=Math.cos(J);n.scale(E,F,Ze*y),n.scale(R,C,Ge*y),n.add(E,E,R);const he=n.add(n.create(),A,E),re=n.add(n.create(),T,E);let Q1=!1;if(X>=0&&n.distance(he,k)<o&&(Q1=!0),!Q1){if(X>=0){H.push(he),K.push(re);const av=[V,re,he,k],lv=i.create(av);D.push(lv)}k=he,V=re}}K.reverse(),D.push(i.create(H)),D.push(i.create(K));const se=s.create(D);P=l(P,se)}),x.forEach(M=>{const _=M[0],S=M[1],A=S[0];let T=null,$=0;for(let I=1;I<S.length;I++){const k=S[I],V=n.cross(E,A,k),H=n.length(V);H>.05&&H>$&&($=H,T=k)}T||(T=n.orthogonal(E,A));const F=n.cross(E,A,T);n.normalize(F,F);const C=n.cross(R,F,A),N=c({center:[_[0],_[1],_[2]],radius:y,segments:q,axes:[A,F,C]});P=l(P,N)}),a(P)},mi}var yi,a1;function pg(){if(a1)return yi;a1=1;const o=L(),e=t1(),t=dg();return yi=(r,s)=>{const i={delta:1,corners:"round",segments:12},{delta:c,corners:a,segments:l}=Object.assign({},i,r);if(a!=="round")throw new Error('corners must be "round" for 3D geometries');if(o.toPolygons(s).length===0)throw new Error("the given geometry cannot be empty");r={delta:c,corners:a,segments:l};const u=t(r,s);return e(s,u)},yi}var xi,l1;function gg(){if(l1)return xi;l1=1;const o=Te(),e=O(),t=G(),n=te(),r=wh(),s=a=>{let{external:l,internal:d}=a;o(l)<0?l=l.reverse():d=d.reverse();const u=n.fromPoints({closed:!0},l),h=n.fromPoints({closed:!0},d),f=t.toSides(t.fromPoints(n.toPoints(u))),v=t.toSides(t.fromPoints(n.toPoints(h)));return f.push(...v),t.create(f)},i=(a,l,d,u)=>{const{points:h,external:f,internal:v}=a,m=Math.floor(l/2),g=[],p=[];if(d==="round"&&m>0){const q=Math.PI/m,P=h[h.length-1],x=e.angle(e.subtract(e.create(),f[f.length-1],P)),w=h[0],E=e.angle(e.subtract(e.create(),v[0],w));for(let R=1;R<m;R++){let b=x+q*R,M=e.fromAngleRadians(e.create(),b);e.scale(M,M,u),e.add(M,M,P),g.push(M),b=E+q*R,M=e.fromAngleRadians(e.create(),b),e.scale(M,M,u),e.add(M,M,w),p.push(M)}}const y=[];return y.push(...f,...g,...v.reverse(),...p),t.fromPoints(y)};return xi=(a,l)=>{a=Object.assign({},{delta:1,corners:"edge",segments:16},a);const{delta:u,corners:h,segments:f}=a;if(u<=0)throw new Error("the given delta must be positive for paths");if(!(h==="edge"||h==="chamfer"||h==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const v=l.isClosed,m=n.toPoints(l);if(m.length===0)throw new Error("the given geometry cannot be empty");const g={points:m,external:r({delta:u,corners:h,segments:f,closed:v},m),internal:r({delta:-u,corners:h,segments:f,closed:v},m)};return l.isClosed?s(g):i(g,f,h,u)},xi}var qi,u1;function f1(){if(u1)return qi;u1=1;const o=U(),e=G(),t=L(),n=te(),r=W0(),s=pg(),i=gg();return qi=(a,...l)=>{if(l=o(l),l.length===0)throw new Error("wrong number of arguments");const d=l.map(u=>n.isA(u)?i(a,u):e.isA(u)?r(a,u):t.isA(u)?s(a,u):u);return d.length===1?d[0]:d},qi}var wi,h1;function vg(){if(h1)return wi;h1=1;const o=te(),e=f1(),t=Ne();return wi=(r,s)=>{const i={size:1,height:1},{size:c,height:a}=Object.assign({},i,r);if(r.delta=c,r.offset=[0,0,a],o.toPoints(s).length===0)throw new Error("the given geometry cannot be empty");const d=e(r,s);return t(r,d)},wi}var Pi,d1;function mg(){if(d1)return Pi;d1=1;const{area:o}=As(),e=G(),t=te(),n=f1(),r=Ne();return Pi=(i,c)=>{const a={size:1,height:1},{size:l,height:d}=Object.assign({},a,i);i.delta=l,i.offset=[0,0,d];const u=e.toOutlines(c);if(u.length===0)throw new Error("the given geometry cannot be empty");const f=u.map(m=>(o(m)<0&&m.reverse(),n(i,t.fromPoints({closed:!0},m)))).reduce((m,g)=>m.concat(e.toSides(g)),[]),v=e.create(f);return r(i,v)},Pi}var Ei,p1;function yg(){if(p1)return Ei;p1=1;const o=U(),e=G(),t=te(),n=vg(),r=mg();return Ei=(i,...c)=>{const a={size:1,height:1},{size:l,height:d}=Object.assign({},a,i);if(c=o(c),c.length===0)throw new Error("wrong number of arguments");if(l<=0)throw new Error("size must be positive");if(d<=0)throw new Error("height must be positive");const u=c.map(h=>t.isA(h)?n(i,h):e.isA(h)?r(i,h):h);return u.length===1?u[0]:u},Ei}var Ri,g1;function xg(){if(g1)return Ri;g1=1;const o=U(),e=Y(),t=oe(),n=G(),r=L(),s=te(),i=(d,...u)=>{const h={origin:[0,0,0],normal:[0,0,1]},{origin:f,normal:v}=Object.assign({},h,d);if(u=o(u),u.length===0)throw new Error("wrong number of arguments");const m=t.fromNormalAndPoint(t.create(),v,f);if(Number.isNaN(m[0]))throw new Error("the given origin and normal do not define a proper plane");const g=e.mirrorByPlane(e.create(),m),p=u.map(y=>s.isA(y)?s.transform(g,y):n.isA(y)?n.transform(g,y):r.isA(y)?r.transform(g,y):y);return p.length===1?p[0]:p};return Ri={mirror:i,mirrorX:(...d)=>i({normal:[1,0,0]},d),mirrorY:(...d)=>i({normal:[0,1,0]},d),mirrorZ:(...d)=>i({normal:[0,0,1]},d)},Ri}var Si,v1;function qg(){if(v1)return Si;v1=1;const{TAU:o}=z(),e=Y(),{mirrorX:t}=xg(),n=G(),r=pe(),s=Fe();return Si=(c,a)=>{const l={segments:12,startAngle:0,angle:o,overflow:"cap"};let{segments:d,startAngle:u,angle:h,overflow:f}=Object.assign({},l,c);if(d<3)throw new Error("segments must be greater then 3");u=Math.abs(u)>o?u%o:u,h=Math.abs(h)>o?h%o:h;let v=u+h;if(v=Math.abs(v)>o?v%o:v,v<u){const b=u;u=v,v=b}let m=v-u;if(m<=0&&(m=o),Math.abs(m)<o){const b=o/d;d=Math.floor(Math.abs(m)/b),Math.abs(m)>d*b&&d++}let g=n.toSides(a);if(g.length===0)throw new Error("the given geometry cannot be empty");const p=g.filter(b=>b[0][0]<0),y=g.filter(b=>b[0][0]>=0);p.length>0&&y.length>0&&f==="cap"&&(p.length>y.length?(g=g.map(b=>{let M=b[0],_=b[1];return M=[Math.min(M[0],0),M[1]],_=[Math.min(_[0],0),_[1]],[M,_]}),a=n.create(g),a=t(a)):y.length>=p.length&&(g=g.map(b=>{let M=b[0],_=b[1];return M=[Math.max(M[0],0),M[1]],_=[Math.max(_[0],0),_[1]],[M,_]}),a=n.create(g)));const P=m/d,x=Math.abs(m)<o,w=r.fromSides(n.toSides(a));r.reverse(w,w);const E=e.create(),R=(b,M,_)=>{let S=P*M+u;return m===o&&M===d&&(S=u),e.multiply(E,e.fromZRotation(E,S),e.fromXRotation(e.create(),o/4)),r.transform(E,_)};return c={numberOfSlices:d+1,capStart:x,capEnd:x,close:!x,callback:R},s(c,w)},Si}var $i,m1;function wg(){if(m1)return $i;m1=1;const{TAU:o}=z(),e=Y(),t=G(),n=Fe(),r=pe();return $i=(i,c)=>{const a={angle:o,startAngle:0,pitch:10,height:0,endOffset:0,segmentsPerRotation:32};let{angle:l,startAngle:d,pitch:u,height:h,endOffset:f,segmentsPerRotation:v}=Object.assign({},a,i);if(h!=0&&(u=h/(l/o)),v<3)throw new Error("The number of segments per rotation needs to be at least 3.");const g=t.toSides(c);if(g.length===0)throw new Error("The given geometry cannot be empty");const p=g.filter(R=>R[0][0]>=0);let y=r.fromSides(g);p.length===0&&(y=r.reverse(y));const q=Math.round(v/o*Math.abs(l)),P=q>=2?q:2,x=e.create(),w=e.create(),E=(R,b,M)=>{const _=d+l/P*b,S=f/P*b,A=(_-d)/o*u;return e.multiply(x,e.fromTranslation(e.create(),[S,0,A*Math.sign(l)]),e.fromXRotation(e.create(),-o/4*Math.sign(l))),e.multiply(w,e.fromZRotation(e.create(),_),x),r.transform(w,M)};return n({numberOfSlices:P+1,callback:E},y)},$i}var _i,y1;function Pg(){if(y1)return _i;y1=1;const o=U(),e=ef(),t=oe(),n=Y(),r=G(),s=L(),i=Z(),c=qe(),a=Jh(),l=(u,h)=>{const f=t.fromNormalAndPoint(t.create(),u.axis,u.origin);if(Number.isNaN(f[0])||Number.isNaN(f[1])||Number.isNaN(f[2])||Number.isNaN(f[3]))throw new Error("project: invalid axis or origin");const v=c(h),m=v*v*Math.sqrt(3)/4;if(v===0)return r.create();const g=s.toPolygons(h);let p=[];for(let q=0;q<g.length;q++){const P=g[q].vertices.map(E=>t.projectionOfPoint(f,E)),x=i.create(P),w=i.plane(x);e(f,w)&&(i.measureArea(x)<m||p.push(x))}if(!e(f,[0,0,1])){const q=n.fromVectorRotation(n.create(),f,[0,0,1]);p=p.map(P=>i.transform(q,P))}p=p.sort((q,P)=>i.measureArea(P)-i.measureArea(q));const y=p.map(q=>r.fromPoints(q.vertices));return a(y)};return _i=(u,...h)=>{const f={axis:[0,0,1],origin:[0,0,0]},{axis:v,origin:m}=Object.assign({},f,u);if(h=o(h),h.length===0)throw new Error("wrong number of arguments");u={axis:v,origin:m};const g=h.map(p=>s.isA(p)?l(u,p):p);return g.length===1?g[0]:g},_i}var bi,x1;function Eg(){return x1||(x1=1,bi={extrudeFromSlices:Fe(),extrudeLinear:V0(),extrudeRectangular:yg(),extrudeRotate:qg(),extrudeHelical:wg(),project:Pg(),slice:pe()}),bi}var Rg=Eg(),Ai,q1;function Sg(){if(q1)return Ai;q1=1;const o=L(),e=ti(),{Tree:t}=ai();return Ai=(r,s)=>{if(!e(r,s))return o.create();const i=new t(o.toPolygons(r)),c=new t(o.toPolygons(s));i.invert(),c.clipTo(i),c.invert(),i.clipTo(c),c.clipTo(i),i.addPolygons(c.allPolygons()),i.invert();const a=i.allPolygons();return o.create(a)},Ai}var Mi,w1;function P1(){if(w1)return Mi;w1=1;const o=U(),e=ke(),t=Sg();return Mi=(...r)=>{r=o(r);let s=r.shift();return r.forEach(i=>{s=t(s,i)}),s=e(s),s},Mi}var Ti,E1;function $g(){if(E1)return Ti;E1=1;const o=U(),e=L(),t=qe(),n=zo(),r=Zo(),s=P1();return Ti=(...c)=>{c=o(c);const a=c.map(u=>r({z0:-1,z1:1},u)),l=s(a),d=t(l);return n(d,e.toPolygons(l))},Ti}var Fi,R1;function _g(){if(R1)return Fi;R1=1;const o=U(),e=Be(),t=G(),n=L(),r=$g(),s=P1();return Fi=(...c)=>{if(c=o(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only intersect of the types are supported");const a=c[0];return t.isA(a)?r(c):n.isA(a)?s(c):a},Fi}var Ci,S1;function bg(){if(S1)return Ci;S1=1;const o=B(),e=qe(),t=L(),n=c=>c.sort((a,l)=>a-l).filter((a,l,d)=>!l||a!==d[l-1]),r=(c,a,l)=>{const d=`${a}`,u=c.get(d);u===void 0?c.set(d,[l]):u.push(l)},s=(c,a)=>{const l=`${a}`;return c.get(l)};return Ci=c=>{const a=e(c),l=t.toPolygons(c),d=l.length,u=new Map,h=o.create();l.forEach((p,y)=>{p.vertices.forEach(q=>{r(u,o.snap(h,q,a),y)})});const f=l.map(p=>{let y=[];return p.vertices.forEach(q=>{y=y.concat(s(u,o.snap(h,q,a)))}),{e:1,d:n(y)}});u.clear();let v=0;const m=f.length;for(let p=0;p<m;p++){const y=f[p];if(y.e>0){const q=new Array(d);q[p]=!0;do v=0,q.forEach((P,x)=>{const w=f[x];if(w.e>0){w.e=-1;for(let E=0;E<w.d.length;E++)q[w.d[E]]=!0;v++}});while(v>0);y.indexes=q}}const g=[];for(let p=0;p<m;p++)if(f[p].indexes){const y=[];f[p].indexes.forEach((q,P)=>y.push(l[P])),g.push(t.create(y))}return g},Ci}var Ni,$1;function Ag(){if($1)return Ni;$1=1;const o=U(),e=L(),t=bg();return Ni=(...r)=>{if(r=o(r),r.length===0)throw new Error("wrong number of arguments");const s=r.map(i=>e.isA(i)?t(i):i);return s.length===1?s[0]:s},Ni}var Ii,_1;function Mg(){if(_1)return Ii;_1=1;const o=L(),e=ti(),{Tree:t}=ai();return Ii=(r,s)=>{if(!e(r,s))return o.clone(r);const i=new t(o.toPolygons(r)),c=new t(o.toPolygons(s));i.invert(),i.clipTo(c),c.clipTo(i,!0),i.addPolygons(c.allPolygons()),i.invert();const a=i.allPolygons();return o.create(a)},Ii}var Bi,b1;function A1(){if(b1)return Bi;b1=1;const o=U(),e=ke(),t=Mg();return Bi=(...r)=>{r=o(r);let s=r.shift();return r.forEach(i=>{s=t(s,i)}),s=e(s),s},Bi}var ki,M1;function Tg(){if(M1)return ki;M1=1;const o=U(),e=L(),t=qe(),n=zo(),r=Zo(),s=A1();return ki=(...c)=>{c=o(c);const a=c.map(u=>r({z0:-1,z1:1},u)),l=s(a),d=t(l);return n(d,e.toPolygons(l))},ki}var Oi,T1;function Fg(){if(T1)return Oi;T1=1;const o=U(),e=Be(),t=G(),n=L(),r=Tg(),s=A1();return Oi=(...c)=>{if(c=o(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only subtract of the types are supported");const a=c[0];return t.isA(a)?r(c):n.isA(a)?s(c):a},Oi}var Vi,F1;function Cg(){return F1||(F1=1,Vi={intersect:_g(),scission:Ag(),subtract:Fg(),union:t1()}),Vi}var Oe=Cg(),C1=G(),Ng=L();/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 *//*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */function Ig(o,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},n,r,s,i;return i={next:c(0),throw:c(1),return:c(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function c(l){return function(d){return a([l,d])}}function a(l){if(n)throw new TypeError("Generator is already executing.");for(;t;)try{if(n=1,r&&(s=l[0]&2?r.return:l[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,l[1])).done)return s;switch(r=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return t.label++,{value:l[1],done:!1};case 5:t.label++,r=l[1],l=[0];continue;case 7:l=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){t=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){t.label=l[1];break}if(l[0]===6&&t.label<s[1]){t.label=s[1],s=l;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(l);break}s[2]&&t.ops.pop(),t.trys.pop();continue}l=e.call(o,t)}catch(d){l=[6,d],r=0}finally{n=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}var ce=(function(){function o(e,t){this.next=null,this.key=e,this.data=t,this.left=null,this.right=null}return o})();function Bg(o,e){return o>e?1:o<e?-1:0}function ae(o,e,t){for(var n=new ce(null,null),r=n,s=n;;){var i=t(o,e.key);if(i<0){if(e.left===null)break;if(t(o,e.left.key)<0){var c=e.left;if(e.left=c.right,c.right=e,e=c,e.left===null)break}s.left=e,s=e,e=e.left}else if(i>0){if(e.right===null)break;if(t(o,e.right.key)>0){var c=e.right;if(e.right=c.left,c.left=e,e=c,e.right===null)break}r.right=e,r=e,e=e.right}else break}return r.right=e.left,s.left=e.right,e.left=n.right,e.right=n.left,e}function Li(o,e,t,n){var r=new ce(o,e);if(t===null)return r.left=r.right=null,r;t=ae(o,t,n);var s=n(o,t.key);return s<0?(r.left=t.left,r.right=t,t.left=null):s>=0&&(r.right=t.right,r.left=t,t.right=null),r}function N1(o,e,t){var n=null,r=null;if(e){e=ae(o,e,t);var s=t(e.key,o);s===0?(n=e.left,r=e.right):s<0?(r=e.right,e.right=null,n=e):(n=e.left,e.left=null,r=e)}return{left:n,right:r}}function kg(o,e,t){return e===null?o:(o===null||(e=ae(o.key,e,t),e.left=o),e)}function Di(o,e,t,n,r){if(o){n(""+e+(t?"└── ":"├── ")+r(o)+`
`);var s=e+(t?"    ":"│   ");o.left&&Di(o.left,s,!1,n,r),o.right&&Di(o.right,s,!0,n,r)}}var zi=(function(){function o(e){e===void 0&&(e=Bg),this._root=null,this._size=0,this._comparator=e}return o.prototype.insert=function(e,t){return this._size++,this._root=Li(e,t,this._root,this._comparator)},o.prototype.add=function(e,t){var n=new ce(e,t);this._root===null&&(n.left=n.right=null,this._size++,this._root=n);var r=this._comparator,s=ae(e,this._root,r),i=r(e,s.key);return i===0?this._root=s:(i<0?(n.left=s.left,n.right=s,s.left=null):i>0&&(n.right=s.right,n.left=s,s.right=null),this._size++,this._root=n),this._root},o.prototype.remove=function(e){this._root=this._remove(e,this._root,this._comparator)},o.prototype._remove=function(e,t,n){var r;if(t===null)return null;t=ae(e,t,n);var s=n(e,t.key);return s===0?(t.left===null?r=t.right:(r=ae(e,t.left,n),r.right=t.right),this._size--,r):t},o.prototype.pop=function(){var e=this._root;if(e){for(;e.left;)e=e.left;return this._root=ae(e.key,this._root,this._comparator),this._root=this._remove(e.key,this._root,this._comparator),{key:e.key,data:e.data}}return null},o.prototype.findStatic=function(e){for(var t=this._root,n=this._comparator;t;){var r=n(e,t.key);if(r===0)return t;r<0?t=t.left:t=t.right}return null},o.prototype.find=function(e){return this._root&&(this._root=ae(e,this._root,this._comparator),this._comparator(e,this._root.key)!==0)?null:this._root},o.prototype.contains=function(e){for(var t=this._root,n=this._comparator;t;){var r=n(e,t.key);if(r===0)return!0;r<0?t=t.left:t=t.right}return!1},o.prototype.forEach=function(e,t){for(var n=this._root,r=[],s=!1;!s;)n!==null?(r.push(n),n=n.left):r.length!==0?(n=r.pop(),e.call(t,n),n=n.right):s=!0;return this},o.prototype.range=function(e,t,n,r){for(var s=[],i=this._comparator,c=this._root,a;s.length!==0||c;)if(c)s.push(c),c=c.left;else{if(c=s.pop(),a=i(c.key,t),a>0)break;if(i(c.key,e)>=0&&n.call(r,c))return this;c=c.right}return this},o.prototype.keys=function(){var e=[];return this.forEach(function(t){var n=t.key;return e.push(n)}),e},o.prototype.values=function(){var e=[];return this.forEach(function(t){var n=t.data;return e.push(n)}),e},o.prototype.min=function(){return this._root?this.minNode(this._root).key:null},o.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},o.prototype.minNode=function(e){if(e===void 0&&(e=this._root),e)for(;e.left;)e=e.left;return e},o.prototype.maxNode=function(e){if(e===void 0&&(e=this._root),e)for(;e.right;)e=e.right;return e},o.prototype.at=function(e){for(var t=this._root,n=!1,r=0,s=[];!n;)if(t)s.push(t),t=t.left;else if(s.length>0){if(t=s.pop(),r===e)return t;r++,t=t.right}else n=!0;return null},o.prototype.next=function(e){var t=this._root,n=null;if(e.right){for(n=e.right;n.left;)n=n.left;return n}for(var r=this._comparator;t;){var s=r(e.key,t.key);if(s===0)break;s<0?(n=t,t=t.left):t=t.right}return n},o.prototype.prev=function(e){var t=this._root,n=null;if(e.left!==null){for(n=e.left;n.right;)n=n.right;return n}for(var r=this._comparator;t;){var s=r(e.key,t.key);if(s===0)break;s<0?t=t.left:(n=t,t=t.right)}return n},o.prototype.clear=function(){return this._root=null,this._size=0,this},o.prototype.toList=function(){return Vg(this._root)},o.prototype.load=function(e,t,n){t===void 0&&(t=[]),n===void 0&&(n=!1);var r=e.length,s=this._comparator;if(n&&Yi(e,t,0,r-1,s),this._root===null)this._root=Gi(e,t,0,r),this._size=r;else{var i=Lg(this.toList(),Og(e,t),s);r=this._size+r,this._root=Zi({head:i},0,r)}return this},o.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(o.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),o.prototype.toString=function(e){e===void 0&&(e=function(n){return String(n.key)});var t=[];return Di(this._root,"",!0,function(n){return t.push(n)},e),t.join("")},o.prototype.update=function(e,t,n){var r=this._comparator,s=N1(e,this._root,r),i=s.left,c=s.right;r(e,t)<0?c=Li(t,n,c,r):i=Li(t,n,i,r),this._root=kg(i,c,r)},o.prototype.split=function(e){return N1(e,this._root,this._comparator)},o.prototype[Symbol.iterator]=function(){var e,t,n;return Ig(this,function(r){switch(r.label){case 0:e=this._root,t=[],n=!1,r.label=1;case 1:return n?[3,6]:e===null?[3,2]:(t.push(e),e=e.left,[3,5]);case 2:return t.length===0?[3,4]:(e=t.pop(),[4,e]);case 3:return r.sent(),e=e.right,[3,5];case 4:n=!0,r.label=5;case 5:return[3,1];case 6:return[2]}})},o})();function Gi(o,e,t,n){var r=n-t;if(r>0){var s=t+Math.floor(r/2),i=o[s],c=e[s],a=new ce(i,c);return a.left=Gi(o,e,t,s),a.right=Gi(o,e,s+1,n),a}return null}function Og(o,e){for(var t=new ce(null,null),n=t,r=0;r<o.length;r++)n=n.next=new ce(o[r],e[r]);return n.next=null,t.next}function Vg(o){for(var e=o,t=[],n=!1,r=new ce(null,null),s=r;!n;)e?(t.push(e),e=e.left):t.length>0?(e=s=s.next=t.pop(),e=e.right):n=!0;return s.next=null,r.next}function Zi(o,e,t){var n=t-e;if(n>0){var r=e+Math.floor(n/2),s=Zi(o,e,r),i=o.head;return i.left=s,o.head=o.head.next,i.right=Zi(o,r+1,t),i}return null}function Lg(o,e,t){for(var n=new ce(null,null),r=n,s=o,i=e;s!==null&&i!==null;)t(s.key,i.key)<0?(r.next=s,s=s.next):(r.next=i,i=i.next),r=r.next;return s!==null?r.next=s:i!==null&&(r.next=i),n.next}function Yi(o,e,t,n,r){if(!(t>=n)){for(var s=o[t+n>>1],i=t-1,c=n+1;;){do i++;while(r(o[i],s)<0);do c--;while(r(o[c],s)>0);if(i>=c)break;var a=o[i];o[i]=o[c],o[c]=a,a=e[i],e[i]=e[c],e[c]=a}Yi(o,e,t,c,r),Yi(o,e,c+1,n,r)}}const ie=11102230246251565e-32,W=134217729,Dg=(3+8*ie)*ie;function Xi(o,e,t,n,r){let s,i,c,a,l=e[0],d=n[0],u=0,h=0;d>l==d>-l?(s=l,l=e[++u]):(s=d,d=n[++h]);let f=0;if(u<o&&h<t)for(d>l==d>-l?(i=l+s,c=s-(i-l),l=e[++u]):(i=d+s,c=s-(i-d),d=n[++h]),s=i,c!==0&&(r[f++]=c);u<o&&h<t;)d>l==d>-l?(i=s+l,a=i-s,c=s-(i-a)+(l-a),l=e[++u]):(i=s+d,a=i-s,c=s-(i-a)+(d-a),d=n[++h]),s=i,c!==0&&(r[f++]=c);for(;u<o;)i=s+l,a=i-s,c=s-(i-a)+(l-a),l=e[++u],s=i,c!==0&&(r[f++]=c);for(;h<t;)i=s+d,a=i-s,c=s-(i-a)+(d-a),d=n[++h],s=i,c!==0&&(r[f++]=c);return(s!==0||f===0)&&(r[f++]=s),f}function zg(o,e){let t=e[0];for(let n=1;n<o;n++)t+=e[n];return t}function we(o){return new Float64Array(o)}const Gg=(3+16*ie)*ie,Zg=(2+12*ie)*ie,Yg=(9+64*ie)*ie*ie,ve=we(4),I1=we(8),B1=we(12),k1=we(16),Q=we(4);function Xg(o,e,t,n,r,s,i){let c,a,l,d,u,h,f,v,m,g,p,y,q,P,x,w,E,R;const b=o-r,M=t-r,_=e-s,S=n-s;P=b*S,h=W*b,f=h-(h-b),v=b-f,h=W*S,m=h-(h-S),g=S-m,x=v*g-(P-f*m-v*m-f*g),w=_*M,h=W*_,f=h-(h-_),v=_-f,h=W*M,m=h-(h-M),g=M-m,E=v*g-(w-f*m-v*m-f*g),p=x-E,u=x-p,ve[0]=x-(p+u)+(u-E),y=P+p,u=y-P,q=P-(y-u)+(p-u),p=q-w,u=q-p,ve[1]=q-(p+u)+(u-w),R=y+p,u=R-y,ve[2]=y-(R-u)+(p-u),ve[3]=R;let A=zg(4,ve),T=Zg*i;if(A>=T||-A>=T||(u=o-b,c=o-(b+u)+(u-r),u=t-M,l=t-(M+u)+(u-r),u=e-_,a=e-(_+u)+(u-s),u=n-S,d=n-(S+u)+(u-s),c===0&&a===0&&l===0&&d===0)||(T=Yg*i+Dg*Math.abs(A),A+=b*d+S*c-(_*l+M*a),A>=T||-A>=T))return A;P=c*S,h=W*c,f=h-(h-c),v=c-f,h=W*S,m=h-(h-S),g=S-m,x=v*g-(P-f*m-v*m-f*g),w=a*M,h=W*a,f=h-(h-a),v=a-f,h=W*M,m=h-(h-M),g=M-m,E=v*g-(w-f*m-v*m-f*g),p=x-E,u=x-p,Q[0]=x-(p+u)+(u-E),y=P+p,u=y-P,q=P-(y-u)+(p-u),p=q-w,u=q-p,Q[1]=q-(p+u)+(u-w),R=y+p,u=R-y,Q[2]=y-(R-u)+(p-u),Q[3]=R;const $=Xi(4,ve,4,Q,I1);P=b*d,h=W*b,f=h-(h-b),v=b-f,h=W*d,m=h-(h-d),g=d-m,x=v*g-(P-f*m-v*m-f*g),w=_*l,h=W*_,f=h-(h-_),v=_-f,h=W*l,m=h-(h-l),g=l-m,E=v*g-(w-f*m-v*m-f*g),p=x-E,u=x-p,Q[0]=x-(p+u)+(u-E),y=P+p,u=y-P,q=P-(y-u)+(p-u),p=q-w,u=q-p,Q[1]=q-(p+u)+(u-w),R=y+p,u=R-y,Q[2]=y-(R-u)+(p-u),Q[3]=R;const F=Xi($,I1,4,Q,B1);P=c*d,h=W*c,f=h-(h-c),v=c-f,h=W*d,m=h-(h-d),g=d-m,x=v*g-(P-f*m-v*m-f*g),w=a*l,h=W*a,f=h-(h-a),v=a-f,h=W*l,m=h-(h-l),g=l-m,E=v*g-(w-f*m-v*m-f*g),p=x-E,u=x-p,Q[0]=x-(p+u)+(u-E),y=P+p,u=y-P,q=P-(y-u)+(p-u),p=q-w,u=q-p,Q[1]=q-(p+u)+(u-w),R=y+p,u=R-y,Q[2]=y-(R-u)+(p-u),Q[3]=R;const C=Xi(F,B1,4,Q,k1);return k1[C-1]}function Hg(o,e,t,n,r,s){const i=(e-s)*(t-r),c=(o-r)*(n-s),a=i-c,l=Math.abs(i+c);return Math.abs(a)>=Gg*l?a:-Xg(o,e,t,n,r,s,l)}var O1={};const Pe=(o,e)=>o.ll.x<=e.x&&e.x<=o.ur.x&&o.ll.y<=e.y&&e.y<=o.ur.y,Hi=(o,e)=>{if(e.ur.x<o.ll.x||o.ur.x<e.ll.x||e.ur.y<o.ll.y||o.ur.y<e.ll.y)return null;const t=o.ll.x<e.ll.x?e.ll.x:o.ll.x,n=o.ur.x<e.ur.x?o.ur.x:e.ur.x,r=o.ll.y<e.ll.y?e.ll.y:o.ll.y,s=o.ur.y<e.ur.y?o.ur.y:e.ur.y;return{ll:{x:t,y:r},ur:{x:n,y:s}}};let le=Number.EPSILON;le===void 0&&(le=Math.pow(2,-52));const Ug=le*le,V1=(o,e)=>{if(-le<o&&o<le&&-le<e&&e<le)return 0;const t=o-e;return t*t<Ug*o*e?0:o<e?-1:1};class Wg{constructor(){this.reset()}reset(){this.xRounder=new L1,this.yRounder=new L1}round(e,t){return{x:this.xRounder.round(e),y:this.yRounder.round(t)}}}class L1{constructor(){this.tree=new zi,this.round(0)}round(e){const t=this.tree.add(e),n=this.tree.prev(t);if(n!==null&&V1(t.key,n.key)===0)return this.tree.remove(e),n.key;const r=this.tree.next(t);return r!==null&&V1(t.key,r.key)===0?(this.tree.remove(e),r.key):e}}const Ee=new Wg,Ve=(o,e)=>o.x*e.y-o.y*e.x,D1=(o,e)=>o.x*e.x+o.y*e.y,z1=(o,e,t)=>{const n=Hg(o.x,o.y,e.x,e.y,t.x,t.y);return n>0?-1:n<0?1:0},Le=o=>Math.sqrt(D1(o,o)),Qg=(o,e,t)=>{const n={x:e.x-o.x,y:e.y-o.y},r={x:t.x-o.x,y:t.y-o.y};return Ve(r,n)/Le(r)/Le(n)},Kg=(o,e,t)=>{const n={x:e.x-o.x,y:e.y-o.y},r={x:t.x-o.x,y:t.y-o.y};return D1(r,n)/Le(r)/Le(n)},G1=(o,e,t)=>e.y===0?null:{x:o.x+e.x/e.y*(t-o.y),y:t},Z1=(o,e,t)=>e.x===0?null:{x:t,y:o.y+e.y/e.x*(t-o.x)},jg=(o,e,t,n)=>{if(e.x===0)return Z1(t,n,o.x);if(n.x===0)return Z1(o,e,t.x);if(e.y===0)return G1(t,n,o.y);if(n.y===0)return G1(o,e,t.y);const r=Ve(e,n);if(r==0)return null;const s={x:t.x-o.x,y:t.y-o.y},i=Ve(s,e)/r,c=Ve(s,n)/r,a=o.x+c*e.x,l=t.x+i*n.x,d=o.y+c*e.y,u=t.y+i*n.y,h=(a+l)/2,f=(d+u)/2;return{x:h,y:f}};class ee{static compare(e,t){const n=ee.comparePoints(e.point,t.point);return n!==0?n:(e.point!==t.point&&e.link(t),e.isLeft!==t.isLeft?e.isLeft?1:-1:ue.compare(e.segment,t.segment))}static comparePoints(e,t){return e.x<t.x?-1:e.x>t.x?1:e.y<t.y?-1:e.y>t.y?1:0}constructor(e,t){e.events===void 0?e.events=[this]:e.events.push(this),this.point=e,this.isLeft=t}link(e){if(e.point===this.point)throw new Error("Tried to link already linked events");const t=e.point.events;for(let n=0,r=t.length;n<r;n++){const s=t[n];this.point.events.push(s),s.point=this.point}this.checkForConsuming()}checkForConsuming(){const e=this.point.events.length;for(let t=0;t<e;t++){const n=this.point.events[t];if(n.segment.consumedBy===void 0)for(let r=t+1;r<e;r++){const s=this.point.events[r];s.consumedBy===void 0&&n.otherSE.point.events===s.otherSE.point.events&&n.segment.consume(s.segment)}}}getAvailableLinkedEvents(){const e=[];for(let t=0,n=this.point.events.length;t<n;t++){const r=this.point.events[t];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&e.push(r)}return e}getLeftmostComparator(e){const t=new Map,n=r=>{const s=r.otherSE;t.set(r,{sine:Qg(this.point,e.point,s.point),cosine:Kg(this.point,e.point,s.point)})};return(r,s)=>{t.has(r)||n(r),t.has(s)||n(s);const{sine:i,cosine:c}=t.get(r),{sine:a,cosine:l}=t.get(s);return i>=0&&a>=0?c<l?1:c>l?-1:0:i<0&&a<0?c<l?-1:c>l?1:0:a<i?-1:a>i?1:0}}}let Jg=0;class ue{static compare(e,t){const n=e.leftSE.point.x,r=t.leftSE.point.x,s=e.rightSE.point.x,i=t.rightSE.point.x;if(i<n)return 1;if(s<r)return-1;const c=e.leftSE.point.y,a=t.leftSE.point.y,l=e.rightSE.point.y,d=t.rightSE.point.y;if(n<r){if(a<c&&a<l)return 1;if(a>c&&a>l)return-1;const u=e.comparePoint(t.leftSE.point);if(u<0)return 1;if(u>0)return-1;const h=t.comparePoint(e.rightSE.point);return h!==0?h:-1}if(n>r){if(c<a&&c<d)return-1;if(c>a&&c>d)return 1;const u=t.comparePoint(e.leftSE.point);if(u!==0)return u;const h=e.comparePoint(t.rightSE.point);return h<0?1:h>0?-1:1}if(c<a)return-1;if(c>a)return 1;if(s<i){const u=t.comparePoint(e.rightSE.point);if(u!==0)return u}if(s>i){const u=e.comparePoint(t.rightSE.point);if(u<0)return 1;if(u>0)return-1}if(s!==i){const u=l-c,h=s-n,f=d-a,v=i-r;if(u>h&&f<v)return 1;if(u<h&&f>v)return-1}return s>i?1:s<i||l<d?-1:l>d?1:e.id<t.id?-1:e.id>t.id?1:0}constructor(e,t,n,r){this.id=++Jg,this.leftSE=e,e.segment=this,e.otherSE=t,this.rightSE=t,t.segment=this,t.otherSE=e,this.rings=n,this.windings=r}static fromRing(e,t,n){let r,s,i;const c=ee.comparePoints(e,t);if(c<0)r=e,s=t,i=1;else if(c>0)r=t,s=e,i=-1;else throw new Error(`Tried to create degenerate segment at [${e.x}, ${e.y}]`);const a=new ee(r,!0),l=new ee(s,!1);return new ue(a,l,[n],[i])}replaceRightSE(e){this.rightSE=e,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const e=this.leftSE.point.y,t=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:e<t?e:t},ur:{x:this.rightSE.point.x,y:e>t?e:t}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(e){return e.x===this.leftSE.point.x&&e.y===this.leftSE.point.y||e.x===this.rightSE.point.x&&e.y===this.rightSE.point.y}comparePoint(e){if(this.isAnEndpoint(e))return 0;const t=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(t.x===n.x)return e.x===t.x?0:e.x<t.x?1:-1;const s=(e.y-t.y)/r.y,i=t.x+s*r.x;if(e.x===i)return 0;const c=(e.x-t.x)/r.x,a=t.y+c*r.y;return e.y===a?0:e.y<a?-1:1}getIntersection(e){const t=this.bbox(),n=e.bbox(),r=Hi(t,n);if(r===null)return null;const s=this.leftSE.point,i=this.rightSE.point,c=e.leftSE.point,a=e.rightSE.point,l=Pe(t,c)&&this.comparePoint(c)===0,d=Pe(n,s)&&e.comparePoint(s)===0,u=Pe(t,a)&&this.comparePoint(a)===0,h=Pe(n,i)&&e.comparePoint(i)===0;if(d&&l)return h&&!u?i:!h&&u?a:null;if(d)return u&&s.x===a.x&&s.y===a.y?null:s;if(l)return h&&i.x===c.x&&i.y===c.y?null:c;if(h&&u)return null;if(h)return i;if(u)return a;const f=jg(s,this.vector(),c,e.vector());return f===null||!Pe(r,f)?null:Ee.round(f.x,f.y)}split(e){const t=[],n=e.events!==void 0,r=new ee(e,!0),s=new ee(e,!1),i=this.rightSE;this.replaceRightSE(s),t.push(s),t.push(r);const c=new ue(r,i,this.rings.slice(),this.windings.slice());return ee.comparePoints(c.leftSE.point,c.rightSE.point)>0&&c.swapEvents(),ee.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),s.checkForConsuming()),t}swapEvents(){const e=this.rightSE;this.rightSE=this.leftSE,this.leftSE=e,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let t=0,n=this.windings.length;t<n;t++)this.windings[t]*=-1}consume(e){let t=this,n=e;for(;t.consumedBy;)t=t.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=ue.compare(t,n);if(r!==0){if(r>0){const s=t;t=n,n=s}if(t.prev===n){const s=t;t=n,n=s}for(let s=0,i=n.rings.length;s<i;s++){const c=n.rings[s],a=n.windings[s],l=t.rings.indexOf(c);l===-1?(t.rings.push(c),t.windings.push(a)):t.windings[l]+=a}n.rings=null,n.windings=null,n.consumedBy=t,n.leftSE.consumedBy=t.leftSE,n.rightSE.consumedBy=t.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const e=this.prev.consumedBy||this.prev;this._beforeState=e.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const e=this.beforeState();this._afterState={rings:e.rings.slice(0),windings:e.windings.slice(0),multiPolys:[]};const t=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let c=0,a=this.rings.length;c<a;c++){const l=this.rings[c],d=this.windings[c],u=t.indexOf(l);u===-1?(t.push(l),n.push(d)):n[u]+=d}const s=[],i=[];for(let c=0,a=t.length;c<a;c++){if(n[c]===0)continue;const l=t[c],d=l.poly;if(i.indexOf(d)===-1)if(l.isExterior)s.push(d);else{i.indexOf(d)===-1&&i.push(d);const u=s.indexOf(l.poly);u!==-1&&s.splice(u,1)}}for(let c=0,a=s.length;c<a;c++){const l=s[c].multiPoly;r.indexOf(l)===-1&&r.push(l)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const e=this.beforeState().multiPolys,t=this.afterState().multiPolys;switch(ne.type){case"union":{const n=e.length===0,r=t.length===0;this._isInResult=n!==r;break}case"intersection":{let n,r;e.length<t.length?(n=e.length,r=t.length):(n=t.length,r=e.length),this._isInResult=r===ne.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(e.length-t.length);this._isInResult=n%2===1;break}case"difference":{const n=r=>r.length===1&&r[0].isSubject;this._isInResult=n(e)!==n(t);break}default:throw new Error(`Unrecognized operation type found ${ne.type}`)}return this._isInResult}}class Y1{constructor(e,t,n){if(!Array.isArray(e)||e.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=t,this.isExterior=n,this.segments=[],typeof e[0][0]!="number"||typeof e[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=Ee.round(e[0][0],e[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let s=r;for(let i=1,c=e.length;i<c;i++){if(typeof e[i][0]!="number"||typeof e[i][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let a=Ee.round(e[i][0],e[i][1]);a.x===s.x&&a.y===s.y||(this.segments.push(ue.fromRing(s,a,this)),a.x<this.bbox.ll.x&&(this.bbox.ll.x=a.x),a.y<this.bbox.ll.y&&(this.bbox.ll.y=a.y),a.x>this.bbox.ur.x&&(this.bbox.ur.x=a.x),a.y>this.bbox.ur.y&&(this.bbox.ur.y=a.y),s=a)}(r.x!==s.x||r.y!==s.y)&&this.segments.push(ue.fromRing(s,r,this))}getSweepEvents(){const e=[];for(let t=0,n=this.segments.length;t<n;t++){const r=this.segments[t];e.push(r.leftSE),e.push(r.rightSE)}return e}}class ev{constructor(e,t){if(!Array.isArray(e))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new Y1(e[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=e.length;n<r;n++){const s=new Y1(e[n],this,!1);s.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=s.bbox.ur.y),this.interiorRings.push(s)}this.multiPoly=t}getSweepEvents(){const e=this.exteriorRing.getSweepEvents();for(let t=0,n=this.interiorRings.length;t<n;t++){const r=this.interiorRings[t].getSweepEvents();for(let s=0,i=r.length;s<i;s++)e.push(r[s])}return e}}class X1{constructor(e,t){if(!Array.isArray(e))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof e[0][0][0]=="number"&&(e=[e])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,r=e.length;n<r;n++){const s=new ev(e[n],this);s.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=s.bbox.ll.x),s.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=s.bbox.ll.y),s.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=s.bbox.ur.x),s.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=s.bbox.ur.y),this.polys.push(s)}this.isSubject=t}getSweepEvents(){const e=[];for(let t=0,n=this.polys.length;t<n;t++){const r=this.polys[t].getSweepEvents();for(let s=0,i=r.length;s<i;s++)e.push(r[s])}return e}}class De{static factory(e){const t=[];for(let n=0,r=e.length;n<r;n++){const s=e[n];if(!s.isInResult()||s.ringOut)continue;let i=null,c=s.leftSE,a=s.rightSE;const l=[c],d=c.point,u=[];for(;i=c,c=a,l.push(c),c.point!==d;)for(;;){const h=c.getAvailableLinkedEvents();if(h.length===0){const m=l[0].point,g=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${m.x}, ${m.y}]. Last matching segment found ends at [${g.x}, ${g.y}].`)}if(h.length===1){a=h[0].otherSE;break}let f=null;for(let m=0,g=u.length;m<g;m++)if(u[m].point===c.point){f=m;break}if(f!==null){const m=u.splice(f)[0],g=l.splice(m.index);g.unshift(g[0].otherSE),t.push(new De(g.reverse()));continue}u.push({index:l.length,point:c.point});const v=c.getLeftmostComparator(i);a=h.sort(v)[0].otherSE;break}t.push(new De(l))}return t}constructor(e){this.events=e;for(let t=0,n=e.length;t<n;t++)e[t].segment.ringOut=this;this.poly=null}getGeom(){let e=this.events[0].point;const t=[e];for(let l=1,d=this.events.length-1;l<d;l++){const u=this.events[l].point,h=this.events[l+1].point;z1(u,e,h)!==0&&(t.push(u),e=u)}if(t.length===1)return null;const n=t[0],r=t[1];z1(n,e,r)===0&&t.shift(),t.push(t[0]);const s=this.isExteriorRing()?1:-1,i=this.isExteriorRing()?0:t.length-1,c=this.isExteriorRing()?t.length:-1,a=[];for(let l=i;l!=c;l+=s)a.push([t[l].x,t[l].y]);return a}isExteriorRing(){if(this._isExteriorRing===void 0){const e=this.enclosingRing();this._isExteriorRing=e?!e.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let e=this.events[0];for(let r=1,s=this.events.length;r<s;r++){const i=this.events[r];ee.compare(e,i)>0&&(e=i)}let t=e.segment.prevInResult(),n=t?t.prevInResult():null;for(;;){if(!t)return null;if(!n)return t.ringOut;if(n.ringOut!==t.ringOut)return n.ringOut.enclosingRing()!==t.ringOut?t.ringOut:t.ringOut.enclosingRing();t=n.prevInResult(),n=t?t.prevInResult():null}}}class H1{constructor(e){this.exteriorRing=e,e.poly=this,this.interiorRings=[]}addInterior(e){this.interiorRings.push(e),e.poly=this}getGeom(){const e=[this.exteriorRing.getGeom()];if(e[0]===null)return null;for(let t=0,n=this.interiorRings.length;t<n;t++){const r=this.interiorRings[t].getGeom();r!==null&&e.push(r)}return e}}class tv{constructor(e){this.rings=e,this.polys=this._composePolys(e)}getGeom(){const e=[];for(let t=0,n=this.polys.length;t<n;t++){const r=this.polys[t].getGeom();r!==null&&e.push(r)}return e}_composePolys(e){const t=[];for(let n=0,r=e.length;n<r;n++){const s=e[n];if(!s.poly)if(s.isExteriorRing())t.push(new H1(s));else{const i=s.enclosingRing();i.poly||t.push(new H1(i)),i.poly.addInterior(s)}}return t}}class nv{constructor(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:ue.compare;this.queue=e,this.tree=new zi(t),this.segments=[]}process(e){const t=e.segment,n=[];if(e.consumedBy)return e.isLeft?this.queue.remove(e.otherSE):this.tree.remove(t),n;const r=e.isLeft?this.tree.add(t):this.tree.find(t);if(!r)throw new Error(`Unable to find segment #${t.id} [${t.leftSE.point.x}, ${t.leftSE.point.y}] -> [${t.rightSE.point.x}, ${t.rightSE.point.y}] in SweepLine tree.`);let s=r,i=r,c,a;for(;c===void 0;)s=this.tree.prev(s),s===null?c=null:s.key.consumedBy===void 0&&(c=s.key);for(;a===void 0;)i=this.tree.next(i),i===null?a=null:i.key.consumedBy===void 0&&(a=i.key);if(e.isLeft){let l=null;if(c){const u=c.getIntersection(t);if(u!==null&&(t.isAnEndpoint(u)||(l=u),!c.isAnEndpoint(u))){const h=this._splitSafely(c,u);for(let f=0,v=h.length;f<v;f++)n.push(h[f])}}let d=null;if(a){const u=a.getIntersection(t);if(u!==null&&(t.isAnEndpoint(u)||(d=u),!a.isAnEndpoint(u))){const h=this._splitSafely(a,u);for(let f=0,v=h.length;f<v;f++)n.push(h[f])}}if(l!==null||d!==null){let u=null;l===null?u=d:d===null?u=l:u=ee.comparePoints(l,d)<=0?l:d,this.queue.remove(t.rightSE),n.push(t.rightSE);const h=t.split(u);for(let f=0,v=h.length;f<v;f++)n.push(h[f])}n.length>0?(this.tree.remove(t),n.push(e)):(this.segments.push(t),t.prev=c)}else{if(c&&a){const l=c.getIntersection(a);if(l!==null){if(!c.isAnEndpoint(l)){const d=this._splitSafely(c,l);for(let u=0,h=d.length;u<h;u++)n.push(d[u])}if(!a.isAnEndpoint(l)){const d=this._splitSafely(a,l);for(let u=0,h=d.length;u<h;u++)n.push(d[u])}}}this.tree.remove(t)}return n}_splitSafely(e,t){this.tree.remove(e);const n=e.rightSE;this.queue.remove(n);const r=e.split(t);return r.push(n),e.consumedBy===void 0&&this.tree.add(e),r}}const U1=typeof process<"u"&&O1.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,rv=typeof process<"u"&&O1.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class sv{run(e,t,n){ne.type=e,Ee.reset();const r=[new X1(t,!0)];for(let u=0,h=n.length;u<h;u++)r.push(new X1(n[u],!1));if(ne.numMultiPolys=r.length,ne.type==="difference"){const u=r[0];let h=1;for(;h<r.length;)Hi(r[h].bbox,u.bbox)!==null?h++:r.splice(h,1)}if(ne.type==="intersection")for(let u=0,h=r.length;u<h;u++){const f=r[u];for(let v=u+1,m=r.length;v<m;v++)if(Hi(f.bbox,r[v].bbox)===null)return[]}const s=new zi(ee.compare);for(let u=0,h=r.length;u<h;u++){const f=r[u].getSweepEvents();for(let v=0,m=f.length;v<m;v++)if(s.insert(f[v]),s.size>U1)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const i=new nv(s);let c=s.size,a=s.pop();for(;a;){const u=a.key;if(s.size===c){const f=u.segment;throw new Error(`Unable to pop() ${u.isLeft?"left":"right"} SweepEvent [${u.point.x}, ${u.point.y}] from segment #${f.id} [${f.leftSE.point.x}, ${f.leftSE.point.y}] -> [${f.rightSE.point.x}, ${f.rightSE.point.y}] from queue.`)}if(s.size>U1)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(i.segments.length>rv)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const h=i.process(u);for(let f=0,v=h.length;f<v;f++){const m=h[f];m.consumedBy===void 0&&s.insert(m)}c=s.size,a=s.pop()}Ee.reset();const l=De.factory(i.segments);return new tv(l).getGeom()}}const ne=new sv;var ov={union:function(o){for(var e=arguments.length,t=new Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];return ne.run("union",o,t)},intersection:function(o){for(var e=arguments.length,t=new Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];return ne.run("intersection",o,t)},xor:function(o){for(var e=arguments.length,t=new Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];return ne.run("xor",o,t)},difference:function(o){for(var e=arguments.length,t=new Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];return ne.run("difference",o,t)}};const ze=(o,e)=>postMessage({ok:!0,id:o,result:e}),iv=(o,e)=>postMessage({ok:!1,id:o,error:String(e)});self.onmessage=o=>{const{id:e,type:t}=o.data;try{if(t==="SANITIZE_PROFILE")return ze(e,W1(o.data.profile));if(t==="PAD_PREVIEW"){const n=W1(o.data.profile),r=cv(n,o.data.height);return ze(e,Ui(r))}if(t==="BOOLEAN_PREVIEW"){const{op:n,a:r,b:s}=o.data,i=n==="UNION"?Oe.union(r,s):n==="SUBTRACT"?Oe.subtract(r,s):Oe.intersect(r,s);return ze(e,Ui(i))}if(t==="TESSELLATE_REFINE")return ze(e,Ui(o.data.shape));throw new Error(`Unknown cmd ${t}`)}catch(n){return iv(e,n)}};function W1(o){const t=i=>i.filter((c,a,l)=>a===0||Math.hypot(c[0]-l[a-1][0],c[1]-l[a-1][1])>1e-6),n=i=>i.reduce((c,[a,l],d)=>{const[u,h]=i[(d+1)%i.length];return c+(a*h-u*l)},0)/2,r=t(o.outer);if(r.length<3)throw new Error("Outer loop < 3 points");n(r)<0&&r.reverse(),ov.union([r]);const s=(o.holes||[]).map(i=>{const c=t(i);return c.length<3?c:n(c)>0?c.reverse():c}).filter(i=>i.length>=3);return{outer:r,holes:s.length?s:void 0}}function cv(o,e){let t=C1.fromPoints(o.outer);for(const n of o.holes||[])t=Oe.subtract(t,C1.fromPoints(n));return Rg.extrudeLinear({height:e},t)}function Ui(o){const e=Ng.toPolygons(o),t=[],n=[],r=[];let s=0;for(const i of e){const c=i.vertices;if(c.length<3)continue;const a=i.plane||[0,0,1,0],[l,d,u]=a,h=s;for(const f of c)t.push(f[0],f[1],f[2]),r.push(l,d,u),s++;for(let f=1;f<c.length-1;f++)n.push(h,h+f,h+f+1)}return{positions:new Float32Array(t),indices:new Uint32Array(n),normals:new Float32Array(r)}}})();
